1
00:00:02,515 --> 00:00:04,420
我們就準備開始

2
00:00:04,420 --> 00:00:08,109
那就是這個很感謝大家來參加我們

3
00:00:08,109 --> 00:00:10,515
這個11月跟12月交接的分享

4
00:00:42,624 --> 00:00:45,365
目前已經有大概三四個不同的主題

5
00:00:45,365 --> 00:00:47,386
就是大方向的主題有被整理出來

6
00:00:47,386 --> 00:00:49,087
那第一個主題我們這次

7
00:00:49,087 --> 00:00:51,268
就是今天要講的Decapling

8
00:00:51,268 --> 00:00:54,589
那Decapling的部分

9
00:00:54,589 --> 00:00:57,650
那個課程的全文其實我已經放在GitHub上

10
00:01:22,311 --> 00:01:24,012
So welcome to my first workshop.

11
00:01:24,012 --> 00:01:28,856
Today we're going to talk about how to turn this mess into this

12
00:01:28,856 --> 00:01:29,236
mess.

13
00:01:29,236 --> 00:01:34,180
And the idea is that at least this mess is modular

14
00:01:34,180 --> 00:01:37,102
and can be combined in meaningful ways

15
00:01:37,102 --> 00:01:39,304
to produce something nice.

16
00:01:39,304 --> 00:01:42,767
Whereas with this one, if you want to debug it,

17
00:01:42,767 --> 00:01:45,769
that's going to be difficult.

18
00:01:45,769 --> 00:01:46,450
Oh, yeah.

19
00:01:46,450 --> 00:01:49,772
Yeah, let me quickly explain.

20
00:01:50,474 --> 00:01:54,678
所以我們看到這個畫面就是像貓玩過的毛線球一樣

21
00:01:54,678 --> 00:01:56,699
就是整個爛掉一坨在一起

22
00:01:56,699 --> 00:01:58,921
那這樣子的高癒合度的情況

23
00:01:58,921 --> 00:02:00,963
就是其實你不管如何要拆解

24
00:02:00,963 --> 00:02:01,683
可能就會非常困難

25
00:02:01,683 --> 00:02:05,306
那如果在座有一些人有自己開發過比較完整的軟體的話

26
00:02:05,306 --> 00:02:08,489
其實你都會知道你的程式開發到後期

27
00:02:08,489 --> 00:02:10,150
可能就是有很多東西都卡在一起

28
00:02:10,150 --> 00:02:12,072
要改一個地方要改五個地方四個地方

29
00:02:12,072 --> 00:02:15,034
然後改了別的地方之後可能其他地方又要跟著改

30
00:02:16,819 --> 00:02:18,520
我們要把它變成像樂高那樣子

31
00:02:18,520 --> 00:02:20,100
雖然看起來有一點混亂

32
00:02:20,100 --> 00:02:22,240
但是至少樂高是很容易

33
00:02:22,240 --> 00:02:24,341
就是你要把哪一個區塊拔掉

34
00:02:24,341 --> 00:02:27,882
要再接到其他地方去是相對比較方便的

35
00:02:27,882 --> 00:02:29,822
就是即便兩個看起來都很混亂

36
00:02:29,822 --> 00:02:33,863
但是有一個至少比較容易使用

37
00:02:33,863 --> 00:02:36,544
Right, and the example I'm gonna use is

38
00:02:36,544 --> 00:02:40,665
So say we're making Diablo clone

39
00:02:40,665 --> 00:02:42,225
Right, we have like a

40
00:02:42,225 --> 00:02:43,806
This is clearly Diablo

41
00:02:45,174 --> 00:02:46,495
我們有健康盤和魔法盤

42
00:03:04,546 --> 00:03:06,427
And right now, they are both hooked up to the health,

43
00:03:06,427 --> 00:03:08,729
so ignore that.

44
00:03:08,729 --> 00:03:10,710
But that's what we're going to talk about, right?

45
00:03:10,710 --> 00:03:17,354
So we have a UI here, and it has the health bar and the mana bar.

46
00:03:17,354 --> 00:03:19,215
And they are just like sliders.

47
00:03:19,215 --> 00:03:25,179
And how do you connect these sliders to these properties

48
00:03:25,179 --> 00:03:25,920
on the player?

49
00:03:29,200 --> 00:03:31,362
畫面上的斜條跟法律條

50
00:03:31,362 --> 00:03:33,944
基本上就只是 UI 元件裡面的

51
00:03:33,944 --> 00:03:37,988
slider 的控制項

52
00:03:37,988 --> 00:03:44,134
要怎麼樣把它接到遊戲中可以設定的數值

53
00:03:44,134 --> 00:03:45,915
屬性參數之類的

54
00:03:45,915 --> 00:03:49,278
這就是這次要主要示範的部分

55
00:03:56,250 --> 00:03:56,591
這一點有點複雜

56
00:03:56,591 --> 00:03:59,892
因為玩家在這裡,UI在那裡

57
00:03:59,892 --> 00:04:00,893
我們只能連接他們

58
00:04:00,893 --> 00:04:04,154
但假設我們有些原因不能這樣做

59
00:04:04,154 --> 00:04:05,775
可能他們在不同的場景

60
00:04:05,775 --> 00:04:07,455
或者玩家被動態複製

61
00:04:07,455 --> 00:04:08,396
或者是其他

62
00:04:08,396 --> 00:04:14,979
我們不能只做一個聯乘的參考

63
00:04:14,979 --> 00:04:18,020
那現在當然這個範例是為了要解釋方便

64
00:04:18,020 --> 00:04:19,161
所以他做的其實是有一點

65
00:04:20,427 --> 00:04:22,907
就是刻意把所有東西都擠在一起

66
00:04:22,907 --> 00:04:25,208
那當你的遊戲變得比較複雜之後

67
00:04:25,208 --> 00:04:28,228
就譬如說你的遊戲同時間有不同的場景

68
00:04:28,228 --> 00:04:30,649
那可能譬如說UI元件是一個場景

69
00:04:30,649 --> 00:04:34,949
然後地圖可能是好幾個場景不同去串接起來的

70
00:04:34,949 --> 00:04:38,470
那到那個時候你可能就很難去

71
00:04:38,470 --> 00:04:40,431
把一些本來應該要相通的數值

72
00:04:40,431 --> 00:04:43,691
要想辦法把那個數值要打通很多道關卡把它串起來

73
00:04:43,691 --> 00:04:45,392
那現在當然就是看起來好像很簡單就是

74
00:04:46,426 --> 00:04:47,887
你做的東西都在同一個地方

75
00:04:47,887 --> 00:04:48,548
那要接起來

76
00:04:48,548 --> 00:04:52,211
理論上你不會需要什麼思考的時間

77
00:04:52,211 --> 00:04:54,374
但這個只是一個範例這樣子

78
00:04:54,374 --> 00:04:56,956
所以我們知道我們在製作Diablo

79
00:04:56,956 --> 00:04:59,038
而在Diablo我們只有一個玩家

80
00:04:59,038 --> 00:05:01,621
Diablo 1

81
00:05:01,621 --> 00:05:02,722
所以一個玩家

82
00:05:02,722 --> 00:05:04,404
聽起來像是

83
00:05:04,404 --> 00:05:05,805
嘿,我們知道一個模式

84
00:05:05,805 --> 00:05:07,667
我們可以用Singleton的模式

85
00:05:11,713 --> 00:05:13,254
目前的範例因為是用

86
00:05:13,254 --> 00:05:15,215
譬如說用 Diablo 以為概念

87
00:05:15,215 --> 00:05:16,996
可能就是你是只有一個主角

88
00:05:16,996 --> 00:05:19,137
一個玩家操作一個角色

89
00:05:19,137 --> 00:05:21,499
理論上這樣的話聽起來好像

90
00:05:21,499 --> 00:05:24,520
既然主角是一個獨一無二的實體

91
00:05:24,520 --> 00:05:25,981
應該主角就可以用 Singleton 模式來實作

92
00:05:41,457 --> 00:05:49,983
常見的Singleton實作方式就是在你的class裡面放一個靜態性別的變數

93
00:05:49,983 --> 00:05:53,365
靜態性別就會變成是一個接近權益變數的概念

94
00:05:53,365 --> 00:05:56,167
你只要能夠access到那個類別

95
00:05:56,167 --> 00:06:01,091
就可以access到唯一的接近權益變數的那個東西

96
00:06:01,091 --> 00:06:02,732
他這邊的命名是man

97
00:06:02,732 --> 00:06:05,494
有時候我們可能會看到他用get instance之類的

98
00:06:05,494 --> 00:06:08,055
就是會有一個固定的名稱去代表唯一的那個實體

99
00:06:08,055 --> 00:06:10,417
Hands up if you use Unity

100
00:06:11,641 --> 00:06:16,546
If you have any questions, please raise your hand.

101
00:06:16,546 --> 00:06:21,710
OK, hands up if you have used singletons.

102
00:06:21,710 --> 00:06:21,770
OK.

103
00:06:21,770 --> 00:06:25,253
So the singleton pattern is really nice and easy, right?

104
00:06:25,253 --> 00:06:30,198
And so it totally works, and we have everything hooked up.

105
00:06:30,198 --> 00:06:34,101
But now, as the game grows more and more complicated,

106
00:06:34,101 --> 00:06:35,643
and now we have to like.

107
00:06:36,873 --> 00:06:40,555
我們有一個UI,有一個玩家

108
00:06:40,555 --> 00:06:41,775
我們要連接資料庫、技能樹、裝備、寶石

109
00:06:41,775 --> 00:06:43,956
然後我們要跟所有東西溝通

110
00:06:43,956 --> 00:06:45,437
最後我們就變成了這個

111
00:06:45,437 --> 00:06:50,880
那Singleton的問題就是

112
00:06:50,880 --> 00:06:53,262
一開始你的遊戲因為結構很簡單

113
00:06:53,262 --> 00:06:54,742
然後可能只有一兩個Singleton

114
00:06:54,742 --> 00:06:55,203
那看起來沒什麼問題

115
00:06:56,080 --> 00:06:58,601
但你如果都用這種思維去設計的話

116
00:06:58,601 --> 00:07:01,322
就用這種思維去設計你的各個遊戲模組的話

117
00:07:01,322 --> 00:07:02,262
你就會發現

118
00:07:02,262 --> 00:07:03,542
你的遊戲到時候

119
00:07:03,542 --> 00:07:04,842
譬如說你的法術書只有一個

120
00:07:04,842 --> 00:07:05,743
那你就會

121
00:07:05,743 --> 00:07:07,303
我法術書也設計成Singleton

122
00:07:07,303 --> 00:07:08,263
然後我的技能術只有一個

123
00:07:08,263 --> 00:07:10,324
所以我技能術也設計成Singleton

124
00:07:10,324 --> 00:07:12,924
然後你就把各種你遊戲中的

125
00:07:12,924 --> 00:07:14,365
聽起來只有一個的實體

126
00:07:14,365 --> 00:07:15,345
你都把它變成Singleton

127
00:07:15,345 --> 00:07:17,586
然後它就會互相串接來串接去

128
00:07:17,586 --> 00:07:18,306
你到時候就會變成是

129
00:07:19,066 --> 00:07:24,550
因為所有的系統,比如說角色跟法術術跟技能術跟這些有的沒的東西都有關聯

130
00:07:24,550 --> 00:07:28,812
所以一個Singleton要跟其他十個Singleton都要reference在一起

131
00:07:28,812 --> 00:07:31,074
然後你的程式結構就會變這樣,就是一坨

132
00:07:31,074 --> 00:07:37,178
Who knows why this might be a problem and what is the problem? Hands up.

133
00:07:37,178 --> 00:07:37,978
OK, so, Demi wants to answer.

134
00:07:51,502 --> 00:07:57,225
So, that computer would require 10x or 20x more than having a better architecture.

135
00:07:57,225 --> 00:07:58,746
Adding something new. OK. What else?

136
00:07:58,746 --> 00:08:03,689
Finding and fixing a bug will take 10x more time.

137
00:08:03,689 --> 00:08:05,910
Debugging. That's very good. Yeah.

138
00:08:05,910 --> 00:08:06,971
Anything else?

139
00:08:06,971 --> 00:08:09,813
Getting new programmers to work on it will take extra training.

140
00:08:09,813 --> 00:08:13,355
Just understanding the entire thing? Having it in your head?

141
00:08:14,243 --> 00:08:15,804
你會想要翻譯一下

142
00:08:41,084 --> 00:08:43,486
And so those are all really good concerns.

143
00:08:43,486 --> 00:08:47,850
I have one more, which is if I want to work on the UI,

144
00:08:47,850 --> 00:08:52,494
if I want to make the UI better, I want to iterate on the UI,

145
00:08:52,494 --> 00:08:55,076
to do that, I have to have everything

146
00:08:55,076 --> 00:08:58,759
that the UI references also available.

147
00:08:58,759 --> 00:09:01,041
Otherwise, I will just have no reference exceptions

148
00:09:01,041 --> 00:09:02,181
all the time.

149
00:09:02,181 --> 00:09:05,264
So I cannot just take out the UI and just work on that.

150
00:09:06,254 --> 00:09:19,163
如果大家有先看過我們原文的話應該知道,我們後面會講到一個例子就是說,你要如何把UI,像UI這樣的組件獨立出來去做各種優化或調整,或是說你要做美化之類的。

151
00:09:19,163 --> 00:09:27,869
那這個東西在團體合作的時候很容易遇到,譬如說你會希望有一個UI設計師或者是一個美術設計師,他就專門做你的2D UI的各種不同的設計。

152
00:09:29,036 --> 00:09:32,438
如果他在設計的 UI 或是改良 UI 的時候

153
00:09:32,438 --> 00:09:34,680
每次都要重新 Rebuild

154
00:09:34,680 --> 00:09:38,442
或是他要想辦法 Reference 到遊戲裡面所有的部件

155
00:09:38,442 --> 00:09:43,226
那你的 Build Time 會很長

156
00:09:43,226 --> 00:09:44,907
然後你調整一個小小的美術效果

157
00:09:44,907 --> 00:09:46,107
可能就要花很多時間

158
00:09:59,354 --> 00:10:02,256
我們這次講 decoupling 的關鍵就是

159
00:10:02,256 --> 00:10:05,860
要如何把中間這些很混亂的連結全部都切斷

160
00:10:05,860 --> 00:10:09,203
然後讓它變成是很容易組裝的跟拆解的配件

161
00:10:21,625 --> 00:10:24,167
or from another angle, when you look up like,

162
00:10:24,167 --> 00:10:26,049
okay, I have singletons, what can I do?

163
00:10:26,049 --> 00:10:28,191
How do I get rid of my singletons?

164
00:10:28,191 --> 00:10:32,695
One thing that you will quickly find on Google

165
00:10:32,695 --> 00:10:34,116
is like dependency injection.

166
00:10:34,116 --> 00:10:36,018
It's always like, okay, dependency injection,

167
00:10:36,018 --> 00:10:37,239
this dependency injection, that.

168
00:10:37,239 --> 00:10:40,522
And it sounds really complicated.

169
00:10:42,371 --> 00:10:46,755
就是在拆解Singleton的這個複雜的相依性的時候

170
00:10:46,755 --> 00:10:48,336
你在Google上面搜尋的時候

171
00:10:48,336 --> 00:10:50,798
很容易看到一個就是現在很流行的一個解法

172
00:10:50,798 --> 00:10:52,860
就是叫做Dependency Injection

173
00:10:52,860 --> 00:10:56,723
那有些人會把它翻譯成相依性或是依賴注入

174
00:10:56,723 --> 00:10:59,365
那就是這個名詞就不太好理解

175
00:10:59,365 --> 00:11:02,968
你沒有辦法很直觀的從名字上看出來到底在幹嘛

176
00:11:02,968 --> 00:11:04,510
然後你翻了一些文件的時候

177
00:11:04,510 --> 00:11:06,131
你會發現這看起來用起來很複雜

178
00:11:06,131 --> 00:11:08,233
就是好像都需要什麼其他的框架

179
00:11:08,233 --> 00:11:09,814
需要一些有的沒的工具來幫你達成

180
00:11:11,253 --> 00:11:13,454
那到底是不是這樣,就請Jonas解答

181
00:11:40,803 --> 00:11:43,843
我不知道它來自哪裡

182
00:11:43,843 --> 00:11:45,524
但是我知道當我活著的時候

183
00:11:45,524 --> 00:11:47,284
當我有一個玩家的例子

184
00:11:47,284 --> 00:11:48,244
它就會在那裡

185
00:11:48,244 --> 00:11:50,825
那就是Dependency Injection

186
00:11:50,825 --> 00:11:52,745
對,那就是

187
00:11:52,745 --> 00:11:55,146
我們這次要講的一個很關鍵的

188
00:11:55,146 --> 00:11:57,226
就是大家可以理解到的事項就是說

189
00:11:57,226 --> 00:11:59,867
其實Unity裡面的Inspector視窗

190
00:11:59,867 --> 00:12:03,267
就是在平常用Unity的時候在右邊的那一欄

191
00:12:03,267 --> 00:12:05,228
其實它本身就是一個注入器

192
00:12:05,228 --> 00:12:08,148
就是它是一個Dependency Injector

193
00:12:08,148 --> 00:12:08,168
那

194
00:12:09,553 --> 00:12:30,801
你在上面掛了很多東西,其實你可以直接對應到程式碼裡面,看起來是一個莫名其妙出現的部分,比如說它是Serialized field,後面寫說Private Controller,Character Controller,或是說什麼Speed,Max Health,就是它上面這些看起來沒有明確來源的這個數值,或是說像那個Character Controller,其實你在這個單元裡面你並沒有辦法看到

195
00:12:31,799 --> 00:12:33,100
他從哪邊引用的

196
00:12:33,100 --> 00:12:34,020
但是他就莫名

197
00:12:34,020 --> 00:12:35,221
就是他好像很神奇

198
00:12:35,221 --> 00:12:36,942
就在這個class裡出現了

199
00:12:36,942 --> 00:12:38,062
那這個原因就是因為其實

200
00:12:38,062 --> 00:12:40,584
Unity的Inspector他本身是有

201
00:12:40,584 --> 00:12:42,264
就是可以直接幫你做這個連結的

202
00:12:42,264 --> 00:12:46,006
Right, so in

203
00:12:46,006 --> 00:12:47,487
and in this case what we could do

204
00:12:47,487 --> 00:12:48,808
instead of using a singleton

205
00:12:48,808 --> 00:12:50,689
is we could like say

206
00:12:50,689 --> 00:12:51,649
OK, here's a player

207
00:12:51,649 --> 00:12:54,091
we don't know how it gets to us

208
00:12:54,091 --> 00:12:55,471
right, it's dependency injection

209
00:12:55,471 --> 00:12:56,312
and then

210
00:12:56,312 --> 00:12:59,573
we get rid of the singleton

211
00:13:03,649 --> 00:13:10,130
現在我們只要連接到 Unity 和 Specter 就可以解決所有問題

212
00:13:10,130 --> 00:13:15,572
而且我們已經沒有 Singleton 了

213
00:13:15,572 --> 00:13:16,472
剛剛看到就是

214
00:13:16,472 --> 00:13:19,733
Jonas 在做這個步驟就是把

215
00:13:19,733 --> 00:13:23,934
原本 Player 裡面有一個 Singleton 實體

216
00:13:23,934 --> 00:13:30,476
他就把 Singleton 的寫法的部分移掉

217
00:13:30,476 --> 00:13:31,676
你會發現就是剛剛在

218
00:13:34,092 --> 00:13:39,273
UI裡面跟在Player原本的類別定義裡面

219
00:13:39,273 --> 00:13:41,294
第一個是沒有Singleton的部分

220
00:13:41,294 --> 00:13:44,815
第二個是要使用Player這個類別的時候

221
00:13:44,815 --> 00:13:47,055
好像就可以很神奇的直接使用

222
00:13:47,055 --> 00:13:49,016
其實因為Player這個類別是

223
00:13:49,016 --> 00:13:51,837
透過Inspector就注入到他剛才要使用的地方

224
00:13:51,837 --> 00:13:52,617
And that works, and that's all good.

225
00:13:52,617 --> 00:13:57,698
But like I said in the beginning, what if we can't do that?

226
00:13:57,698 --> 00:14:00,599
What if we cannot just connect it?

227
00:14:02,646 --> 00:14:05,607
在Edit Mode

228
00:14:05,607 --> 00:14:07,708
因為在Runtime

229
00:14:07,708 --> 00:14:10,909
是Dynamically Created

230
00:14:10,909 --> 00:14:11,669
或是類似的,那你會怎麼做?

231
00:14:11,669 --> 00:14:11,909
剛剛我們講到的問題就是說

232
00:14:11,909 --> 00:14:14,830
假設像我們剛剛有提到說

233
00:14:14,830 --> 00:14:16,550
如果你沒有辦法用這樣子很直接

234
00:14:16,550 --> 00:14:18,811
在同一個場景下面把這兩件事情

235
00:14:18,811 --> 00:14:22,392
用Unity Inspector連起來的時候

236
00:14:22,392 --> 00:14:23,432
譬如說你有兩個場景

237
00:14:23,432 --> 00:14:26,053
或是譬如說你的需要操作的角色

238
00:14:26,053 --> 00:14:26,573
他可能是動態產生的

239
00:14:29,545 --> 00:14:30,185
這種時候你要

240
00:14:30,185 --> 00:14:33,486
就是你沒有辦法在 editor 裡面直接去做這件連結的時候

241
00:14:33,486 --> 00:14:33,866
那你要怎麼辦?

242
00:15:01,334 --> 00:15:04,715
其實有另外一個很重要的觀察就是

243
00:15:04,715 --> 00:15:09,156
你在其他地方要使用玩家的東西

244
00:15:09,156 --> 00:15:10,716
就是玩家這個類別

245
00:15:10,716 --> 00:15:12,156
Player這個類別裡面的一些東西

246
00:15:12,156 --> 00:15:14,397
所以你看到其他像UI參考到的部分

247
00:15:14,397 --> 00:15:17,937
其實就只有玩家底下的特定幾個資料

248
00:15:17,937 --> 00:15:19,338
那其實你真的需要使用的

249
00:15:19,338 --> 00:15:21,918
你真的需要在其他的模組裡面

250
00:15:21,918 --> 00:15:23,518
使用玩家相關的東西的時候

251
00:15:23,518 --> 00:15:26,519
其實你是只有需要使用玩家的資料而已

252
00:15:26,519 --> 00:15:29,440
那假設我們可以把資料的部分

253
00:15:29,440 --> 00:15:29,900
單獨抽出來的話

254
00:15:31,018 --> 00:15:31,658
那是不是就可以解決這個問題

255
00:16:04,910 --> 00:16:19,583
And so now we can say, OK, so the player now looks like it

256
00:16:19,583 --> 00:16:32,394
doesn't compile.

257
00:16:32,394 --> 00:16:32,594
No.

258
00:16:36,872 --> 00:16:38,492
Player now looks like this.

259
00:16:38,492 --> 00:16:45,254
And the player expects data to be assigned.

260
00:16:45,254 --> 00:16:51,275
We do that by creating bounded floats here.

261
00:16:51,275 --> 00:16:53,555
So we can test.

262
00:16:53,555 --> 00:16:55,656
剛剛看到主要的修改就是

263
00:16:55,656 --> 00:16:58,897
他把原本就是用float

264
00:16:58,897 --> 00:17:02,217
就是一個浮點數最基本型別浮點數

265
00:17:02,217 --> 00:17:04,118
來代表的某幾個數值

266
00:17:04,118 --> 00:17:05,818
就把它包裝成一個

267
00:17:06,932 --> 00:17:09,393
叫做Bounded Float的一個類別

268
00:17:09,393 --> 00:17:11,854
那這個Bounded Float其實是一個

269
00:17:11,854 --> 00:17:13,615
就是剛提到的Scriptable Object

270
00:17:13,615 --> 00:17:15,395
在Unity裡面的一個

271
00:17:15,395 --> 00:17:18,156
特殊用來儲存

272
00:17:18,156 --> 00:17:20,937
資料用的一個方式

273
00:17:20,937 --> 00:17:22,978
那

274
00:17:22,978 --> 00:17:25,659
他現在就是把這個東西

275
00:17:25,659 --> 00:17:27,140
獨立出來之後

276
00:17:27,140 --> 00:17:28,240
他變成可以

277
00:17:28,240 --> 00:17:29,861
直接在Inspector裡面去

278
00:17:31,525 --> 00:17:37,511
原本每一個血量跟法力

279
00:17:37,511 --> 00:17:39,453
你都需要各兩個數值去代表它

280
00:17:39,453 --> 00:17:40,714
一個是最大值,一個是現在值

281
00:17:40,714 --> 00:17:43,517
現在可以透過另外一個方式去指定它

282
00:17:51,041 --> 00:17:53,922
Player can reference it and Player can modify it

283
00:17:53,922 --> 00:17:58,104
And now we do the same thing to the status bar

284
00:17:58,104 --> 00:18:01,805
So instead of saying we want a reference to the player

285
00:18:01,805 --> 00:18:07,807
We just want a reference to a value

286
00:18:07,807 --> 00:18:08,867
剛剛提到說

287
00:18:08,867 --> 00:18:11,648
你其實真的需要使用的

288
00:18:11,648 --> 00:18:13,969
目前這個建造需要真的使用的東西

289
00:18:13,969 --> 00:18:15,950
其實不是Player裡面的其他功能

290
00:18:15,950 --> 00:18:20,151
而是只是跟玩家相關的一組數值

291
00:18:20,151 --> 00:18:20,171
那

292
00:18:20,952 --> 00:18:24,753
它在Status Bar裡面甚至就不需要去參考Player這個類別

293
00:18:24,753 --> 00:18:29,174
它只需要去參考某個Value

294
00:18:29,174 --> 00:18:31,294
那這個Value是剛剛講的

295
00:18:31,294 --> 00:18:36,015
用Script Object去延伸出來的Bounded Float

296
00:18:52,057 --> 00:18:55,338
Player, so this is linked to the test house, which I have here.

297
00:18:55,338 --> 00:18:55,899
Oh yeah, seems to work.

298
00:18:55,899 --> 00:18:56,799
Right, so you want to translate that?

299
00:18:56,799 --> 00:18:58,039
好,那就是剛最後一步他們在Jonas在展示就只是單純是說

300
00:18:58,039 --> 00:18:58,960
那我們剛把這個Status bar的寫法修改了之後

301
00:18:58,960 --> 00:18:59,620
他可以直接從Status bar

302
00:19:22,229 --> 00:19:24,710
連接到Data裡面的

303
00:19:24,710 --> 00:19:27,271
Test Health跟Test Mana這些資訊

304
00:19:27,271 --> 00:19:30,753
而不是說

305
00:19:30,753 --> 00:19:32,954
某一個是用原本的程式

306
00:19:32,954 --> 00:19:35,835
就是寫在你的Player Class裡面的數值去代表

307
00:19:35,835 --> 00:19:39,156
那它Data的部分就會單純存在Asset的Data底下

308
00:19:39,156 --> 00:19:40,857
所以這四個東西

309
00:19:40,857 --> 00:19:43,218
嚴格上來說它跟任何Class都沒有直接的關聯

310
00:19:43,218 --> 00:19:44,599
它就變成只是一個資料而已

311
00:19:50,708 --> 00:19:55,594
我們直接連接玩家和slider,

312
00:19:55,594 --> 00:19:59,938
我們連接玩家和slider到數據上。

313
00:19:59,938 --> 00:20:00,539
所以我們的圖表現在是這樣子。

314
00:20:10,896 --> 00:20:13,278
其實現在玩家的血量跟玩家的法力

315
00:20:13,278 --> 00:20:15,661
他已經不存在玩家那個類別裡面了

316
00:20:15,661 --> 00:20:17,483
那他單獨拉出來之後

317
00:20:17,483 --> 00:20:20,225
UI可以單獨的去存取這兩個資料

318
00:20:20,225 --> 00:20:21,406
那玩家類別

319
00:20:21,406 --> 00:20:24,369
假設你玩家有一些其他的功能要寫

320
00:20:24,369 --> 00:20:27,813
他也需要去存取法力跟血量的資料的話

321
00:20:27,813 --> 00:20:29,514
他也是就是單獨的去存取

322
00:20:29,514 --> 00:20:30,936
其實就已經

323
00:20:30,936 --> 00:20:33,639
UI跟Player這兩個類別中間

324
00:20:33,639 --> 00:20:34,259
就完全沒有什麼關聯了

325
00:20:35,393 --> 00:20:40,695
And the key thing is there's absolutely no error between these two, right?

326
00:20:40,695 --> 00:20:43,896
These are totally separate from each other now.

327
00:20:43,896 --> 00:20:46,877
就是現在UI跟玩家裡面如果有任何錯誤的話

328
00:20:46,877 --> 00:20:48,817
它互相並不會影響到

329
00:20:48,817 --> 00:20:51,538
因為UI這個類別跟玩家這個類別已經是完全獨立的個體

330
00:20:51,538 --> 00:20:56,379
Like I can create a new scene and drop a UI in there

331
00:20:56,379 --> 00:20:57,920
because I want to work on the UI.

332
00:20:59,703 --> 00:21:03,185
and I assign some data

333
00:21:03,185 --> 00:21:06,688
doesn't even have to be the real one

334
00:21:06,688 --> 00:21:10,130
and I can already play that

335
00:21:10,130 --> 00:21:12,311
and it just plays, it works

336
00:21:12,311 --> 00:21:14,653
and I can play around with values

337
00:21:14,653 --> 00:21:17,515
I can animate them or whatever

338
00:21:17,515 --> 00:21:19,676
if I want to work on the UI

339
00:21:19,676 --> 00:21:23,639
I can do that now without worrying about anything else

340
00:21:23,639 --> 00:21:25,800
那現在這個就是剛剛講到的

341
00:21:25,800 --> 00:21:26,080
如何把

342
00:21:27,798 --> 00:21:31,919
資料拆解出來之後如何在完全獨立的無關的場景裡面

343
00:21:31,919 --> 00:21:35,100
如果你要做測試、你要做修改

344
00:21:35,100 --> 00:21:36,540
單純針對UI做修改的話

345
00:21:36,540 --> 00:21:37,220
你都可以做到

346
00:21:37,220 --> 00:21:40,021
就是不需要把像剛剛提到的玩家

347
00:21:40,021 --> 00:21:41,481
其他功能的類別全部都吃進來

348
00:21:41,481 --> 00:21:46,602
現在就只有隨意設置的一個測試用的數值

349
00:21:46,602 --> 00:21:49,563
那這個測試用的數值可以直接反映在你現在要工作的區域

350
00:21:49,563 --> 00:21:51,363
就是UI上面

351
00:21:51,363 --> 00:21:52,464
那你的UI就只跟這幾個數值有關聯

352
00:21:58,781 --> 00:22:00,682
玩家跟UI溝通的原因是因為他們分享相同的數據

353
00:22:00,682 --> 00:22:00,922
但測試的話

354
00:22:00,922 --> 00:22:02,242
我們可以在測試數據上運行

355
00:22:02,242 --> 00:22:02,923
我們可以完全複製

356
00:22:02,923 --> 00:22:04,363
做我們想要的東西

357
00:22:04,363 --> 00:22:05,344
所以這對測試和獨立的使用來說是非常好的

358
00:22:05,344 --> 00:22:06,864
那這就是今天要講的

359
00:22:06,864 --> 00:22:08,245
今天要講的其實關鍵最後就只有這樣

360
00:22:22,352 --> 00:22:25,575
你可以把這些資料單獨拆離出來之後

361
00:22:25,575 --> 00:22:30,258
那你之後譬如說誰要去設計一個新的UI的顯示方式

362
00:22:30,258 --> 00:22:32,539
或者是說他要做一些UI上的測試

363
00:22:32,539 --> 00:22:35,602
他可以直接建立一個新的空場景

364
00:22:35,602 --> 00:22:37,783
然後把他要測試的元件拉進去

365
00:22:37,783 --> 00:22:40,445
然後設定一些像剛剛講的Test Health、Test Mana

366
00:22:40,445 --> 00:22:41,025
就是這些測試用的數值

367
00:22:43,173 --> 00:22:46,375
那這個數值當然不是真的大家最後會使用到真正裝在裡面的數值

368
00:22:46,375 --> 00:22:47,996
就是單純測試使用的

369
00:22:47,996 --> 00:22:50,158
他可以直接在Edit裡面去操縱他

370
00:22:50,158 --> 00:22:54,301
或是他去做一些動畫或是動態的調整

371
00:22:54,301 --> 00:22:55,842
那都可以直接做到

372
00:22:55,842 --> 00:22:59,004
就這個場景本身跟遊戲本體

373
00:22:59,004 --> 00:23:02,487
你真正最後的完整遊戲是完全無關的一個場景

374
00:23:02,487 --> 00:23:04,908
但是他可以使用操作這個意外的部分

375
00:23:05,610 --> 00:23:08,912
So let's see if we solved all the problems we mentioned earlier.

376
00:23:08,912 --> 00:23:13,335
Um, one was test in isolation. That was mine. And I, uh, okay,

377
00:23:13,335 --> 00:23:16,397
that's solved. He was saying, uh,

378
00:23:16,397 --> 00:23:21,500
bring on new people and, and like make them understand how the thing works.

379
00:23:21,500 --> 00:23:26,363
Um, I would hope that is easier now because you can like look at the UI in

380
00:23:26,363 --> 00:23:30,686
isolation and just understand that, um,

381
00:23:30,686 --> 00:23:31,667
debugging.

382
00:23:32,270 --> 00:23:37,853
Debugging right we if we want to debug like if we have a bug in the player

383
00:23:37,853 --> 00:23:43,756
We can just debug the player without having to have like inventory and everything around and we can

384
00:23:43,756 --> 00:23:49,279
Look at all the data and modify all the data and see like what triggers the bug and

385
00:23:49,279 --> 00:23:52,701
Then adding news new things to the system

386
00:23:55,084 --> 00:23:59,448
It should also be relatively easy as our data grows.

387
00:23:59,448 --> 00:24:02,872
We keep it in here and then new systems

388
00:24:02,872 --> 00:24:06,216
can either use the existing data or you

389
00:24:06,216 --> 00:24:07,777
put more data in here.

390
00:24:07,777 --> 00:24:12,823
So I hope that all of these are a little bit easier.

391
00:24:14,135 --> 00:24:15,517
那我們一開始提到的

392
00:24:15,517 --> 00:24:17,798
其實就是剛剛Demi還有Jonas

393
00:24:17,798 --> 00:24:19,860
在對談的時候提到的問題就是

394
00:24:19,860 --> 00:24:20,701
第一個是

395
00:24:20,701 --> 00:24:21,942
程式的要理解上的困難

396
00:24:21,942 --> 00:24:24,183
然後要debug上的困難

397
00:24:24,183 --> 00:24:27,486
然後還有要增加新的人來理解

398
00:24:27,486 --> 00:24:29,007
這個程式的架構的時候的困難

399
00:24:29,007 --> 00:24:30,328
還有最後你需要

400
00:24:30,328 --> 00:24:31,509
快速的液態的時候

401
00:24:31,509 --> 00:24:34,231
快速的疊代的時候會遇到困難

402
00:24:34,231 --> 00:24:36,493
那把這東西拆開之後就發現

403
00:24:36,493 --> 00:24:39,215
如果你有一個辦法可以

404
00:24:39,215 --> 00:24:40,876
譬如說我今天要講做UI的東西

405
00:24:40,876 --> 00:24:41,417
我就只看這個場景

406
00:24:41,417 --> 00:24:41,437
那

407
00:24:43,507 --> 00:24:47,389
比如我要增加一個新的UI設計師

408
00:24:47,389 --> 00:24:52,172
我要增加一個新的UI程式設計的程式員

409
00:24:52,172 --> 00:24:54,654
那他可以只管UI這部分

410
00:24:54,654 --> 00:24:56,035
他也只需要理解這部分

411
00:24:56,035 --> 00:24:57,656
那他會造成的Bug

412
00:24:57,656 --> 00:24:59,898
他會加一些新東西造成的Bug

413
00:24:59,898 --> 00:25:01,199
基本上也只會出現在UI這邊

414
00:25:01,199 --> 00:25:03,500
他不會因為UI這邊改了什麼東西

415
00:25:03,500 --> 00:25:07,923
然後遊戲裡面其他的部件就因此壞掉

416
00:25:07,923 --> 00:25:08,844
那最後就是

417
00:25:10,045 --> 00:25:13,587
希望這樣子讓整體的這個程式的模組

418
00:25:13,587 --> 00:25:16,188
互相拆解之後

419
00:25:16,188 --> 00:25:18,148
要互相重新組裝的這個速度

420
00:25:18,148 --> 00:25:22,250
還有這個各種實作的方式

421
00:25:22,250 --> 00:25:23,110
就是可以變快這樣

422
00:25:23,110 --> 00:25:28,912
Any questions or comments?

423
00:25:28,912 --> 00:25:29,592
看有沒有大家有什麼問題

424
00:25:29,592 --> 00:25:31,893
好你就直接講我幫你擺

425
00:25:34,127 --> 00:25:35,008
這問題大概有兩個點

426
00:25:35,008 --> 00:25:37,889
一個是可以看看實作面上

427
00:25:37,889 --> 00:25:40,149
因為如果把參數獨立出來

428
00:25:40,149 --> 00:25:42,570
那它的實作量

429
00:25:42,570 --> 00:25:45,011
實作上參數的量會達到多大

430
00:25:45,011 --> 00:25:46,952
就是有辦法可以秀

431
00:25:46,952 --> 00:25:48,913
看一下它的實作面

432
00:25:48,913 --> 00:25:50,293
真的已經在使用這個方式

433
00:25:50,293 --> 00:25:54,454
所以你要看雷射是 production code 實際上

434
00:25:54,454 --> 00:25:56,635
大概對實作面上像 data 量

435
00:25:56,635 --> 00:25:59,816
如果獨立抽成一個 split table 的話

436
00:25:59,816 --> 00:26:00,156
就是要用

437
00:26:00,963 --> 00:26:02,604
我想找一個理由

438
00:26:02,604 --> 00:26:03,005
那第二問題是

439
00:26:03,005 --> 00:26:03,185
相則意義

440
00:26:22,437 --> 00:26:27,843
give a very rough estimate on how much data there will be

441
00:26:27,843 --> 00:26:30,806
in a typical live project.

442
00:26:30,806 --> 00:26:33,268
So if the project's already in production

443
00:26:33,268 --> 00:26:35,550
and it's like a functional game

444
00:26:35,550 --> 00:26:39,294
and it's maybe double-way scale,

445
00:26:39,294 --> 00:26:41,957
how much data are we talking about?

446
00:26:41,957 --> 00:26:44,560
Do you see, you only have like four?

447
00:26:45,521 --> 00:26:50,264
floats here in the asset data, right?

448
00:26:50,264 --> 00:26:51,946
So what if it's Subnautica?

449
00:26:51,946 --> 00:26:53,807
Would it be like 2,000 data?

450
00:26:53,807 --> 00:26:56,809
It would probably be more.

451
00:26:56,809 --> 00:27:00,512
But the thing is, we're already dealing

452
00:27:00,512 --> 00:27:02,253
with thousands of objects.

453
00:27:02,253 --> 00:27:05,595
We're dealing with thousands of prefabs, usually.

454
00:27:05,595 --> 00:27:08,017
So prefabs have data.

455
00:27:08,017 --> 00:27:10,679
Before I started refactoring this,

456
00:27:10,679 --> 00:27:13,641
all the data was inside.

457
00:27:14,767 --> 00:27:16,148
inside the player, right?

458
00:27:16,148 --> 00:27:18,089
It was like right there.

459
00:27:18,089 --> 00:27:21,492
So in terms of memory, it was already in memory.

460
00:27:21,492 --> 00:27:25,755
We're not making the computers slower or anything.

461
00:27:25,755 --> 00:27:28,998
In terms of managing for humans, we already

462
00:27:28,998 --> 00:27:33,342
have ways to organize our prefabs

463
00:27:33,342 --> 00:27:35,703
with folders and names.

464
00:27:35,703 --> 00:27:36,844
The same would apply to data.

465
00:27:36,844 --> 00:27:40,327
It's essentially the same thing.

466
00:27:41,480 --> 00:27:44,521
Yes, you will have like thousands of these objects

467
00:27:44,521 --> 00:27:48,382
But you're comfortable dealing with thousands of textures

468
00:27:48,382 --> 00:27:51,924
thousands of prefabs, thousands of any kind of assets

469
00:27:51,924 --> 00:27:59,547
So why would you not be comfortable dealing with thousands of data objects, data assets?

470
00:27:59,547 --> 00:28:01,968
Next, 這樣

471
00:28:01,968 --> 00:28:03,288
沒有,沒有,他的意思就是說

472
00:28:03,288 --> 00:28:07,290
就是你在把這些資料拆出來之前

473
00:28:08,320 --> 00:28:12,141
你可能也會需要經手幾百個幾千個prefab

474
00:28:12,141 --> 00:28:13,301
或者是幾百個幾千個

475
00:28:13,301 --> 00:28:14,722
本來就放在asset底下

476
00:28:14,722 --> 00:28:16,862
其他資料夾可能是material

477
00:28:16,862 --> 00:28:17,722
可能是prefab

478
00:28:17,722 --> 00:28:20,143
可能是script裡面的物件

479
00:28:20,143 --> 00:28:22,343
本來就可能有幾百個幾千個

480
00:28:22,343 --> 00:28:24,444
那你現在把data這部分

481
00:28:24,444 --> 00:28:25,504
也看成是某一種

482
00:28:25,504 --> 00:28:27,425
你本來就必須會用到的

483
00:28:27,425 --> 00:28:28,365
會需要管理的資料

484
00:28:28,365 --> 00:28:30,365
它也是幾百個幾千個

485
00:28:30,365 --> 00:28:31,386
那理論上

486
00:28:31,386 --> 00:28:32,566
就你本來就已經在處理這麼多

487
00:28:34,912 --> 00:28:37,132
數量的物體,而且它們還更複雜

488
00:28:37,132 --> 00:28:40,233
那單獨的把 data 抽出來之後

489
00:28:40,233 --> 00:28:43,214
它應該也不會到你完全無法掌握的程度

490
00:28:43,214 --> 00:28:44,334
然後你可以用命名

491
00:28:44,334 --> 00:28:46,055
就是原本你可能在管控

492
00:28:46,055 --> 00:28:47,995
譬如你有幾百個 prefix 的情況下

493
00:28:47,995 --> 00:28:49,636
你可能命名規則去管理

494
00:28:49,636 --> 00:28:52,036
譬如說場景裡面什麼 prefix

495
00:28:52,036 --> 00:28:54,777
還是說什麼類型的物件的 prefix

496
00:28:54,777 --> 00:28:55,357
該叫什麼名字

497
00:28:55,357 --> 00:28:57,598
有一個 prefix 啊 suffix 之類的

498
00:28:57,598 --> 00:28:59,758
你就去做命名的調整嘛

499
00:28:59,758 --> 00:28:59,778
那

500
00:29:00,765 --> 00:29:04,546
你應該也可以用同樣類似的技巧來管理

501
00:29:04,546 --> 00:29:06,806
單獨抽離出來之後的資料

502
00:29:06,806 --> 00:29:11,727
譬如說也是一樣用命名規則去

503
00:29:11,727 --> 00:29:13,108
讓變數更容易

504
00:29:13,108 --> 00:29:16,328
讓資料更容易被找到跟管理

505
00:29:16,328 --> 00:29:20,509
對,資料量就是會這麼大

506
00:29:32,304 --> 00:29:41,932
Like if you had all your, if you had like a thousand player variables,

507
00:29:41,932 --> 00:29:43,093
could you then just build a player...

508
00:29:43,093 --> 00:29:46,496
Oh sorry, if you had a thousand player variables, could you just build like a

509
00:29:46,496 --> 00:29:48,538
player proxy that then references all those

510
00:29:48,538 --> 00:29:51,220
variables and then you just have one player object?

511
00:29:51,220 --> 00:29:55,383
Yeah. The references all those, so it makes it easier for them

512
00:29:55,383 --> 00:29:57,585
to like pass around...

513
00:29:58,204 --> 00:30:00,889
So basically you're trying to build it like a namespace kind of thing.

514
00:30:00,889 --> 00:30:01,750
Yeah, like...

515
00:30:01,750 --> 00:30:03,293
You can nest these things, right? You can say, OK, we have a...

516
00:30:10,641 --> 00:30:15,504
Yeah, because then you've got all your test variables and all your normal variables,

517
00:30:15,504 --> 00:30:20,867
and then to test your test variables, you don't have to drag everything into the scene to test the testing.

518
00:30:20,867 --> 00:30:25,510
You could just drag your test player in that references all the test ones,

519
00:30:25,510 --> 00:30:30,433
and then you have your production player that references all the production ones.

520
00:30:32,359 --> 00:30:37,623
就是管理那個Script Object所創造出來的資料的時候

521
00:30:37,623 --> 00:30:39,525
你也可以用槽狀的方式去管理

522
00:30:39,525 --> 00:30:41,326
譬如說跟玩家有關的

523
00:30:41,326 --> 00:30:43,708
你全部都包在另外一個class裡面

524
00:30:43,708 --> 00:30:46,330
就是你可能會階層會再多一層

525
00:30:46,330 --> 00:30:49,392
但是那個階層它

526
00:30:49,392 --> 00:30:52,394
就譬如說你有個Player Data Structure

527
00:30:52,394 --> 00:30:54,896
或是說Player Proxy Structure

528
00:30:54,896 --> 00:30:57,098
那裡面也是一樣全部都只有資料

529
00:30:57,098 --> 00:30:58,559
它沒有功能

530
00:30:58,559 --> 00:30:59,740
它沒有function 沒有method對

531
00:31:04,252 --> 00:31:09,113
然後它再一個一個連結更細微的資料進去

532
00:31:34,401 --> 00:31:35,842
Oh, yeah, right.

533
00:31:35,842 --> 00:31:41,127
Like, it gets a little bit, there's

534
00:31:41,127 --> 00:31:45,731
a little bit more boilerplate you have to write to do that.

535
00:31:45,731 --> 00:31:50,075
But it's essentially the same thing, right?

536
00:31:50,075 --> 00:31:56,640
So I think organizing it, that can be done.

537
00:31:56,640 --> 00:31:58,742
OK, second question.

538
00:32:00,922 --> 00:32:08,645
像Prayer這個事情預設在遊戲edit的時候就已經決定可能有一個Prayer這種狀態

539
00:32:08,645 --> 00:32:13,087
可是如果是要即時建立像假設場景內有100隻敵人

540
00:32:13,087 --> 00:32:15,008
那每隻敵人頭上有UIBAR這樣

541
00:32:15,008 --> 00:32:19,949
那這UIBAR本身連結到Scriptable是Runtime來建立的嗎?

542
00:32:19,949 --> 00:32:22,350
或像這種情形下的話

543
00:32:22,350 --> 00:32:23,971
是要怎麼處理?

544
00:32:23,971 --> 00:32:25,211
How do you deal with...

545
00:32:27,902 --> 00:32:31,806
a dynamic object which also connects to dynamic script

546
00:32:31,806 --> 00:32:32,846
of object data.

547
00:32:32,846 --> 00:32:33,847
Right.

548
00:32:33,847 --> 00:32:35,288
Right.

549
00:32:35,288 --> 00:32:36,029
Can you give me a concrete example?

550
00:32:36,029 --> 00:32:39,912
So his example was, maybe say you have a scene

551
00:32:39,912 --> 00:32:42,474
and you have 100 enemies.

552
00:32:42,474 --> 00:32:46,197
And those 100 enemies, they at least

553
00:32:46,197 --> 00:32:52,683
have, say, 100 different health bars.

554
00:32:52,683 --> 00:32:56,566
So they're referenced to 100 individual health value.

555
00:32:57,613 --> 00:32:59,893
And all those are dynamically created.

556
00:32:59,893 --> 00:33:00,774
How do you manage that in the same way?

557
00:33:00,774 --> 00:33:01,794
OK, so scriptable object data is only

558
00:33:01,794 --> 00:33:03,234
good for things that are shared across a class of prefabs.

559
00:33:03,234 --> 00:33:04,935
In this case, I have player health and player mana.

560
00:33:26,557 --> 00:33:28,999
which works because there's one player.

561
00:33:28,999 --> 00:33:31,461
If I have two players, and they would both link

562
00:33:31,461 --> 00:33:34,023
to the same player health and player mana,

563
00:33:34,023 --> 00:33:36,044
they would have shared player health and mana.

564
00:33:36,044 --> 00:33:39,707
That's not what, typically, it's not what you want.

565
00:33:39,707 --> 00:33:41,068
Especially if you have enemies,

566
00:33:41,068 --> 00:33:44,711
you probably want them to have their own health.

567
00:33:44,711 --> 00:33:48,514
So in that case, you would still put the health in here.

568
00:33:48,514 --> 00:33:50,356
Directly into the-

569
00:33:50,356 --> 00:33:52,598
In their own class, in their own class, right?

570
00:33:52,598 --> 00:33:54,819
Do you mean in their own class?

571
00:33:55,153 --> 00:33:57,234
Yeah, in the monobehavior.

572
00:33:57,234 --> 00:34:01,176
If this is enemy and it's monobehavior,

573
00:34:01,176 --> 00:34:03,717
it would still be like this.

574
00:34:03,717 --> 00:34:09,839
Player speed just belongs to the player instance.

575
00:34:09,839 --> 00:34:14,341
So if the question is, how do you then

576
00:34:14,341 --> 00:34:19,283
get those dynamically created instance data out

577
00:34:19,283 --> 00:34:21,584
into something else that uses that?

578
00:34:24,522 --> 00:34:25,803
我的問題是,那是什麼樣的用途?

579
00:34:25,803 --> 00:34:28,945
我意思是,有用途,但我們先找一個

580
00:34:46,415 --> 00:34:47,356
同時 share

581
00:34:47,356 --> 00:34:48,838
就是它的血量的資料

582
00:34:48,838 --> 00:34:49,978
就是我們現在還是講在

583
00:34:49,978 --> 00:34:51,900
如何 share 資料這件事情

584
00:34:51,900 --> 00:34:55,423
那它的資料會被哪一些其他元件 share

585
00:34:55,423 --> 00:34:57,925
你說血量這一塊就是

586
00:34:57,925 --> 00:34:59,126
因為照

587
00:34:59,126 --> 00:35:01,388
假設我們就剛說的是它是動態產生的

588
00:35:01,388 --> 00:35:03,510
所以動態產生每一組可能每一支 DN

589
00:35:03,510 --> 00:35:05,792
就會有自己獨立一個血量的資料

590
00:35:05,792 --> 00:35:08,855
那這資料它不可能會變成 scriptable 的方式

591
00:35:08,855 --> 00:35:12,498
存在因為不會跨 editor 跟 runtime

592
00:35:12,498 --> 00:35:13,359
所以像這種情形下

593
00:35:14,701 --> 00:35:17,302
它是變成會有兩組的方式去管理

594
00:35:17,302 --> 00:35:19,423
就是可能player就是像這樣

595
00:35:19,423 --> 00:35:22,344
用scriptable去存資料

596
00:35:22,344 --> 00:35:25,305
敵人就是用另一個方式去管理這樣

597
00:35:25,305 --> 00:35:25,685
那它的應該

598
00:35:25,685 --> 00:35:30,787
直接用它的script

599
00:35:30,787 --> 00:35:31,308
就是其實

600
00:35:31,308 --> 00:35:32,308
所以就不用這個方式了

601
00:35:32,308 --> 00:35:35,209
它的概念會比較像是說會用scriptable

602
00:35:35,209 --> 00:35:38,191
嚴格上來講也是某一種蠻不得已的情況

603
00:35:38,191 --> 00:35:40,772
就是因為你這個資料

604
00:35:40,772 --> 00:35:41,452
它會被

605
00:35:42,460 --> 00:35:43,321
第一個是它有唯一性

606
00:35:43,321 --> 00:35:47,402
然後第二個是它會被各種不同的模組同時存取

607
00:35:47,402 --> 00:35:52,104
那這種類型的資料你把它抽出來變成Scriptal object

608
00:35:52,104 --> 00:35:57,926
那如果說你有些資料它被存取的地方很固定

609
00:35:57,926 --> 00:36:04,928
或者說它本來就沒有類似的共享的需求的話

610
00:36:04,928 --> 00:36:06,629
它就不應該出現在Scriptal object裡面

611
00:36:08,570 --> 00:36:12,112
他們專案在使用上其實也會分開來使用

612
00:36:12,112 --> 00:36:15,414
就是並不是全部都統一化使用這個方式去做

613
00:36:38,705 --> 00:36:40,045
So the idea-

614
00:36:40,045 --> 00:36:41,346
Which talk?

615
00:36:41,346 --> 00:36:42,907
Is the 2017 one or 2016 one?

616
00:36:42,907 --> 00:36:47,129
The one from Ryan, the Ryan, the 2017 one.

617
00:36:47,129 --> 00:36:47,469
Okay.

618
00:36:47,469 --> 00:36:52,391
So what's that called, run time sets?

619
00:36:52,391 --> 00:36:53,632
Run time sets, yeah.

620
00:36:53,632 --> 00:36:56,793
So that's just what he calls it.

621
00:36:56,793 --> 00:36:58,694
I don't think it's a good name,

622
00:36:58,694 --> 00:37:00,815
but I don't have a better name.

623
00:37:00,815 --> 00:37:04,297
So that's a like custom defined name?

624
00:37:04,297 --> 00:37:05,317
It's not a Unity?

625
00:37:05,317 --> 00:37:06,178
No, it's not a Unity.

626
00:37:07,312 --> 00:37:13,498
OK, so the idea would be to have data that represents a set,

627
00:37:13,498 --> 00:37:14,539
something that belongs together.

628
00:37:14,539 --> 00:37:17,522
So say, for example, I have a runtime set

629
00:37:17,522 --> 00:37:19,364
which is a scriptable object.

630
00:37:28,079 --> 00:37:29,780
which just has a list of enemies.

631
00:37:29,780 --> 00:37:30,561
Oh, OK.

632
00:37:30,561 --> 00:37:35,044
And this is like the scriptable object itself

633
00:37:35,044 --> 00:37:36,425
doesn't even serialize anything.

634
00:37:36,425 --> 00:37:37,986
It's completely empty.

635
00:37:37,986 --> 00:37:40,808
But the nice thing about it is it is data.

636
00:37:40,808 --> 00:37:43,290
And I can now from anywhere in the game,

637
00:37:43,290 --> 00:37:45,191
I can reference this thing.

638
00:37:45,191 --> 00:37:49,935
And if I am an enemy, I can put myself into the list.

639
00:37:49,935 --> 00:37:53,417
And if I am like some kind of.

640
00:37:55,693 --> 00:38:00,195
Other system that needs to know where is the next enemy I can look

641
00:38:00,195 --> 00:38:01,616
Up all the enemies from that list

642
00:38:01,616 --> 00:38:02,857
Without

643
00:38:02,857 --> 00:38:08,399
Without the enemies and the threat system directly talking to each other

644
00:38:08,399 --> 00:38:12,441
Let me program that while you translate it

645
00:38:12,441 --> 00:38:18,824
另外一個解法是剛剛Jonas有提到說在原本我們的那個文件裡面最後有個延伸閱讀的部分

646
00:38:18,824 --> 00:38:23,226
那有兩個影片連結那第一個影片連結是Unite Austin 2017年的

647
00:38:23,924 --> 00:38:29,168
一個演講,它的標題是Game Architecture with Scripted Objects

648
00:38:29,168 --> 00:38:32,051
那它裡面有提到一個做法就是

649
00:38:32,051 --> 00:38:38,596
你,就是現在Jonas正在很快速的寫個範例的這個做法就是說

650
00:38:38,596 --> 00:38:39,697
你可以把那些需要動態產生的東西的資料

651
00:38:39,697 --> 00:38:42,740
也還是把它寫在Scripted Objects裡面

652
00:38:47,972 --> 00:38:52,713
但是裡面就放了不是一個原本一開始在程式裡面就定義好的一個屬性

653
00:38:52,713 --> 00:38:53,714
或是一個欄位

654
00:38:53,714 --> 00:38:55,394
而是你就放一個 list

655
00:38:55,394 --> 00:39:00,535
那個 list 是可以動態增加元素或是移除元素的

656
00:39:00,535 --> 00:39:03,296
那如果你有一個動態的敵人產生的時候

657
00:39:03,296 --> 00:39:08,578
你就把跟這個敵人相關的資訊需要被共享的部分

658
00:39:08,578 --> 00:39:12,359
你就把它放到那個 list 裡面

659
00:39:12,359 --> 00:39:14,639
那可能那敵人掛掉的時候

660
00:39:14,639 --> 00:39:16,820
你就再把那個元素移掉這樣子

661
00:39:18,077 --> 00:39:24,381
So the enemy would on start just add itself to the list and on destroy remove itself from the list

662
00:39:24,381 --> 00:39:29,805
It doesn't know where the list is. That is dependency injection again and

663
00:39:29,805 --> 00:39:31,787
then some other

664
00:39:31,787 --> 00:39:35,330
class for example the player

665
00:39:35,330 --> 00:39:39,773
Okay, let's let's make a method here

666
00:39:39,773 --> 00:39:40,594
Closest enemy

667
00:39:47,617 --> 00:39:49,078
Wait, am I translating this right?

668
00:39:49,078 --> 00:39:54,362
So did you put enemies directly in the script of object

669
00:39:54,362 --> 00:39:56,623
as a list?

670
00:39:56,623 --> 00:39:59,445
Or are you putting, say, enemy health?

671
00:39:59,445 --> 00:40:04,088
I'm putting the enemy component directly into it at runtime.

672
00:40:04,088 --> 00:40:04,708
At runtime.

673
00:40:04,708 --> 00:40:04,968
Right, OK.

674
00:40:04,968 --> 00:40:06,489
Not at edit time.

675
00:40:06,489 --> 00:40:08,671
And then I'm referencing it here.

676
00:40:18,795 --> 00:40:20,977
What was it?

677
00:40:20,977 --> 00:40:22,918
Runtime set.

678
00:40:22,918 --> 00:40:26,039
The naming is completely bad now.

679
00:40:26,039 --> 00:40:27,540
Runtime set, yeah.

680
00:40:27,540 --> 00:40:28,701
But I hope you get the idea.

681
00:40:28,701 --> 00:40:33,263
My question would be, if you want

682
00:40:33,263 --> 00:40:39,127
to separate data from functional or behaviors,

683
00:40:39,127 --> 00:40:39,727
would EVG?

684
00:40:43,656 --> 00:40:47,817
good to put the enemy entities or like enemy instances,

685
00:40:47,817 --> 00:40:51,479
all of the enemy stuff inside that list,

686
00:40:51,479 --> 00:40:54,019
or you just want to put data

687
00:40:54,019 --> 00:40:56,880
relative to that enemy into that list?

688
00:40:56,880 --> 00:40:58,581
It depends, it depends.

689
00:40:58,581 --> 00:41:05,443
But the goal is not to separate data and behavior.

690
00:41:05,443 --> 00:41:10,125
The goal is to separate things

691
00:41:10,125 --> 00:41:12,045
that shouldn't be coupled together.

692
00:41:12,664 --> 00:41:17,486
It's totally fine for behavior and data to be coupled together

693
00:41:17,486 --> 00:41:19,327
as long as it's a module,

694
00:41:19,327 --> 00:41:21,747
as long as it stays within those bounds.

695
00:41:21,747 --> 00:41:22,088
Right.

696
00:41:22,088 --> 00:41:26,429
It's totally fine for an enemy health to be directly on the enemy.

697
00:41:26,429 --> 00:41:26,609
Right.

698
00:41:26,609 --> 00:41:31,151
It's not the goal to get all the data out into a scriptable object.

699
00:41:31,151 --> 00:41:31,391
Right.

700
00:41:31,391 --> 00:41:37,713
We only do that because that data has to be shared with other systems.

701
00:41:37,713 --> 00:41:38,734
Right. Okay.

702
00:41:39,887 --> 00:41:40,927
所以我剛剛有點翻譯錯誤

703
00:41:40,927 --> 00:41:45,468
他現在是直接把 enemy 這個類別直接

704
00:41:45,468 --> 00:41:49,409
就是 enemy 這個實體

705
00:41:49,409 --> 00:41:51,229
這個 monobehavior 繼承來的這個物件

706
00:41:51,229 --> 00:41:53,930
直接放到 script object 裡面的那個 list

707
00:41:53,930 --> 00:41:56,371
他不是只有把敵人的血量

708
00:41:56,371 --> 00:41:58,571
或什麼相關的資料放到那個 list 裡面

709
00:41:58,571 --> 00:42:01,152
那 Jonas 的解釋是說

710
00:42:01,152 --> 00:42:03,913
目標並不是要把所有的資料

711
00:42:03,913 --> 00:42:08,354
都從類別行為裡面 decouple 出來

712
00:42:08,354 --> 00:42:08,594
而是

713
00:42:11,811 --> 00:42:16,734
就是我們要減少的是各種不同模組之間的相依性

714
00:42:16,734 --> 00:42:21,436
而不是說把所有的資料全部都切出來

715
00:42:21,436 --> 00:42:24,678
那假設你的

716
00:42:24,678 --> 00:42:28,460
譬如說敵人的血量跟敵人的行為本身是非常緊密連結的

717
00:42:28,460 --> 00:42:31,542
他本來就不太可以分開

718
00:42:31,542 --> 00:42:33,623
然後你的敵人血量

719
00:42:33,623 --> 00:42:38,245
需要參考敵人血量的這個其他物件或是模組也數量沒有很多

720
00:42:39,081 --> 00:42:42,063
那也許這個資料就還是要跟原本它那個

721
00:42:42,063 --> 00:42:43,643
應該就是在一起的實體是要綁在一起的

722
00:42:43,643 --> 00:42:44,504
Right

723
00:42:44,504 --> 00:42:47,966
I think you get the idea, right?

724
00:42:47,966 --> 00:42:50,227
If I make some enemies

725
00:42:50,227 --> 00:43:00,993
I assign the runtime set that they are supposed to register themselves to

726
00:43:00,993 --> 00:43:07,196
And then I can make that like an enemy prefab

727
00:43:10,948 --> 00:43:13,550
Okay, and then at runtime,

728
00:43:13,550 --> 00:43:18,873
I can instantiate some enemies and

729
00:43:18,873 --> 00:43:25,396
they would all be, like, instantiate some enemies.

730
00:43:25,396 --> 00:43:30,238
And now this runtime set, which we don't have a debugger for,

731
00:43:30,238 --> 00:43:33,300
but you just have to believe me, it would now contain.

732
00:43:34,167 --> 00:43:34,828
Two enemies?

733
00:43:34,828 --> 00:43:38,532
Uh, three enemies because I spawned these three enemies, right?

734
00:43:38,532 --> 00:43:41,556
And so the player, if I also drop the player into the scene...

735
00:43:41,556 --> 00:43:41,596
Oh.

736
00:43:41,596 --> 00:43:41,736
No floor!

737
00:43:41,736 --> 00:43:41,836
Okay.

738
00:43:41,836 --> 00:43:43,077
Yeah, the player can...

739
00:43:54,624 --> 00:44:00,029
reference those enemies and then if the player needs to know,

740
00:44:00,029 --> 00:44:02,311
okay, which one is the closest enemy,

741
00:44:02,311 --> 00:44:03,812
you can get that from the list.

742
00:44:03,812 --> 00:44:09,157
There's no, at no point have I registered like enemies to

743
00:44:09,157 --> 00:44:12,099
the player or players to the enemy or any of that.

744
00:44:12,099 --> 00:44:15,542
It all goes down to data and then the data is,

745
00:44:15,542 --> 00:44:17,784
in this case, is a list.

746
00:44:19,010 --> 00:44:25,453
It's essentially just a list, this list.

747
00:44:25,453 --> 00:44:26,954
That list is then shared between the two systems.

748
00:44:26,954 --> 00:44:31,857
So yeah, and so if those enemies now had health or something,

749
00:44:31,857 --> 00:44:36,760
and you need to do something, you need to, I don't know,

750
00:44:36,760 --> 00:44:41,302
display 100 health bars in the UI,

751
00:44:41,302 --> 00:44:46,865
you could go through this list and pull out 100 health values.

752
00:44:49,152 --> 00:44:55,054
就是剛在演示的內容就是說如何

753
00:44:55,054 --> 00:44:57,335
因為現在沒有時間把這麼多程式寫出來

754
00:44:57,335 --> 00:45:00,876
但是他剛剛就是手動的方式去建立了幾個

755
00:45:00,876 --> 00:45:03,337
Enemy實體在場景裡面

756
00:45:03,337 --> 00:45:05,978
然後理論上這個Enemy的

757
00:45:05,978 --> 00:45:07,578
Script Object List

758
00:45:07,578 --> 00:45:09,439
他就會 因為剛剛有寫那個

759
00:45:09,439 --> 00:45:11,159
他會把自己的Data註冊進這個List

760
00:45:13,062 --> 00:45:14,542
一小片段的程式

761
00:45:14,542 --> 00:45:15,703
那理論上

762
00:45:15,703 --> 00:45:17,924
現在因為沒有辦法去用 Debugger 去看說

763
00:45:17,924 --> 00:45:19,204
到底那個 list 裡面

764
00:45:19,204 --> 00:45:19,944
現在存了幾個物件

765
00:45:19,944 --> 00:45:21,925
但是理論上現在就是裡面會有

766
00:45:21,925 --> 00:45:22,926
三個 enemy 物件

767
00:45:22,926 --> 00:45:25,727
然後如果你在玩家的

768
00:45:25,727 --> 00:45:28,028
這個類別裡面要去找出說

769
00:45:28,028 --> 00:45:29,628
我現在離我玩家最接近的

770
00:45:29,628 --> 00:45:31,769
譬如說剛剛幾個敵人裡面哪個是最接近的

771
00:45:31,769 --> 00:45:33,770
那你在跑另外一個 code 的時候

772
00:45:33,770 --> 00:45:37,271
需要去存取現在的 enemy 的那個列表

773
00:45:37,271 --> 00:45:39,432
你就可以直接從這個 script object 裡面去拉出來

774
00:45:40,507 --> 00:45:42,168
然後你可能再去看說這個敵人的血量是多少

775
00:45:42,168 --> 00:45:43,889
那你可能攻擊他的時候這個血量會扣多少什麼之類的

776
00:45:43,889 --> 00:45:44,049
這個再去從那邊計算

777
00:45:44,049 --> 00:45:45,469
Great questions, more questions

778
00:45:45,469 --> 00:45:48,691
It's probably worth knowing as well that as this scriptable object

779
00:45:48,691 --> 00:45:50,672
It's a class and you can have methods on it and whatever

780
00:45:50,672 --> 00:45:51,192
So you could move that

781
00:46:09,370 --> 00:46:15,671
找到最親近的敵人進入Runtime的Set Class

782
00:46:15,671 --> 00:46:17,372
這比較特別是對敵人來說

783
00:46:17,372 --> 00:46:22,633
而不是對玩家

784
00:46:22,633 --> 00:46:24,213
這意味著你可以

785
00:46:24,213 --> 00:46:25,633
為了敵人

786
00:46:25,633 --> 00:46:25,833
找到

787
00:46:25,833 --> 00:46:27,774
他的最親近敵人

788
00:46:27,774 --> 00:46:30,314
或是他的最親近朋友對

789
00:46:30,314 --> 00:46:30,955
Ed的建議是因為

790
00:46:38,111 --> 00:46:40,894
其實剛剛寫的這個方法

791
00:46:40,894 --> 00:46:43,236
它是名字叫做Find Closest Enemy

792
00:46:43,236 --> 00:46:46,198
那其實這個方法本身跟

793
00:46:46,198 --> 00:46:48,941
你要找尋的敵人

794
00:46:48,941 --> 00:46:51,303
就是跟敵人這個類別其實觀念比較接近

795
00:46:51,303 --> 00:46:53,665
那理論上可以把這個方法

796
00:46:53,665 --> 00:46:55,406
也直接放到Script Object底下

797
00:46:55,406 --> 00:46:59,770
那理論上你就可以在不同的

798
00:46:59,770 --> 00:47:02,112
也許不是只有玩家要

799
00:47:03,617 --> 00:47:05,377
找出最接近他的敵人

800
00:47:05,377 --> 00:47:06,558
你可能也有其他的東西

801
00:47:06,558 --> 00:47:08,199
需要找出最接近的敵人是什麼

802
00:47:08,199 --> 00:47:09,699
那大家就可以共享那個方法

803
00:47:09,699 --> 00:47:11,500
那這個方法就可以寫在

804
00:47:11,500 --> 00:47:15,222
就是呃

805
00:47:15,222 --> 00:47:16,843
現在他應該正在搬運

806
00:47:16,843 --> 00:47:19,264
在refactor那個方法

807
00:47:19,264 --> 00:47:19,684
已經搬過去了

808
00:47:19,684 --> 00:47:22,105
所以現在變成是enemies

809
00:47:22,105 --> 00:47:24,026
然後find closest

810
00:47:24,026 --> 00:47:25,027
所以就變成不是

811
00:47:25,027 --> 00:47:27,188
就是這個方法不是由

812
00:47:27,188 --> 00:47:27,708
玩家這個類別來實作

813
00:47:27,708 --> 00:47:29,189
而是直接實作在enemy

814
00:47:33,364 --> 00:47:34,845
to go scripted object here.

815
00:47:34,845 --> 00:47:39,449
That's a very good point. Yeah, there's lots of things you can,

816
00:47:39,449 --> 00:47:41,871
lots of methods that really are more

817
00:47:41,871 --> 00:47:44,433
about the data than about the behavior of the data.

818
00:47:44,433 --> 00:47:47,115
So those do make

819
00:47:47,115 --> 00:47:49,817
a lot of sense to put them directly into the script object.

820
00:47:49,817 --> 00:47:51,839
For example here, right now,

821
00:47:51,839 --> 00:47:54,280
these are public and there's

822
00:47:54,280 --> 00:47:58,224
no check that value is actually smaller than max value.

823
00:47:58,224 --> 00:48:02,107
So I probably want to encapsulate that.

824
00:48:02,585 --> 00:48:06,648
and would have to have a proper set value function that

825
00:48:06,648 --> 00:48:12,613
actually makes sure that it is never above max value.

826
00:48:12,613 --> 00:48:15,014
So once you start separating out your data,

827
00:48:15,014 --> 00:48:17,336
you will probably find that you also

828
00:48:17,336 --> 00:48:19,918
want to put in a lot of methods that

829
00:48:19,918 --> 00:48:27,724
are more about the data than about the behaviors of whatever

830
00:48:27,724 --> 00:48:28,224
uses the data.

831
00:48:29,998 --> 00:48:31,639
另外一個剛想到的就是說

832
00:48:31,639 --> 00:48:36,742
另外一個類似的範例就是

833
00:48:36,742 --> 00:48:41,506
剛在玩家的這個屬性資料裡面

834
00:48:41,506 --> 00:48:43,607
就是他也是被建立成一個Scriptal object

835
00:48:43,607 --> 00:48:47,029
但是如果你需要檢查這個資料本身正不正確

836
00:48:47,029 --> 00:48:50,071
或是說他有沒有出現一些異常數值的時候

837
00:48:50,071 --> 00:48:52,793
你可能還是會需要呼叫一些方法來保證說

838
00:48:52,793 --> 00:48:57,616
譬如說你的目前數值不能大於最大值

839
00:48:57,616 --> 00:48:57,957
像這些資訊

840
00:48:59,861 --> 00:49:02,762
你當然可以在玩家那個Lab裡面

841
00:49:02,762 --> 00:49:04,442
去寫這個方法

842
00:49:04,442 --> 00:49:06,663
但是其實既然這個方法本身

843
00:49:06,663 --> 00:49:08,864
只跟資料的驗證有關的話

844
00:49:08,864 --> 00:49:11,084
那其實他應該要寫在

845
00:49:11,084 --> 00:49:13,885
Script Object資料底下

846
00:49:13,885 --> 00:49:16,906
這樣子這個方法才會跟這個資料

847
00:49:16,906 --> 00:49:19,947
就是相關的東西會比較容易放在一起

848
00:49:19,947 --> 00:49:23,608
然後而且這個方法本身也不是屬於

849
00:49:23,608 --> 00:49:25,648
就是玩家本身的一些行為

850
00:49:25,648 --> 00:49:27,629
就是這個物件或是這個實體本身的一些行為

851
00:49:27,629 --> 00:49:27,649
那

852
00:49:28,765 --> 00:49:30,687
他比較偏向是說

853
00:49:30,687 --> 00:49:32,008
你只是在調閱資料

854
00:49:32,008 --> 00:49:34,590
你只是在整理資料或是驗證資料

855
00:49:34,590 --> 00:49:36,972
那他這些方法就應該跟資料類別放在一起

856
00:49:56,435 --> 00:50:00,418
they won't be able to add multiplayer because of,

857
00:50:00,418 --> 00:50:04,360
I think, something related to these issues, right?

858
00:50:04,360 --> 00:50:07,042
Then, have you released multiplayer?

859
00:50:07,042 --> 00:50:11,024
What was the problem there that would take,

860
00:50:11,024 --> 00:50:15,267
it's saying it would be better if we just wrote it from the slides.

861
00:50:15,267 --> 00:50:20,971
Right. Do you want to translate the question?

862
00:50:20,971 --> 00:50:22,332
Okay.

863
00:50:23,438 --> 00:50:31,061
So, like, the summary is Subnautica doesn't have multiplayer, at some point...

864
00:50:31,061 --> 00:50:32,682
Someone wanted to add a mod to it.

865
00:50:32,682 --> 00:50:39,384
No, no, at some point we wanted to do it, but then at some point we decided, OK, we're not going to do it, it's too much work.

866
00:50:39,384 --> 00:50:39,945
Right.

867
00:50:39,945 --> 00:50:40,325
That was in 2016.

868
00:50:40,325 --> 00:50:41,165
So the question is, like, why?

869
00:50:41,165 --> 00:50:42,826
And, like, would this help?

870
00:50:42,826 --> 00:50:47,608
And would it be...

871
00:50:53,105 --> 00:50:56,427
比較容易重新開啟或是重新開啟

872
00:50:56,427 --> 00:50:58,289
請問我有沒有答錯

873
00:50:58,289 --> 00:51:04,033
就是這問題是說因為Jonas他之前就是在做Subnautica這款的主人是

874
00:51:04,033 --> 00:51:08,457
剛剛問題是說Subnautica在2016年的時候

875
00:51:08,457 --> 00:51:11,940
好像有打算要加入就是多人的

876
00:51:11,940 --> 00:51:12,880
玩法

877
00:51:12,880 --> 00:51:14,101
因為之前都是這個遊戲都只有單人而已

878
00:51:15,982 --> 00:51:20,984
The multi-player mode had this idea at first, but it was abandoned later

879
00:51:20,984 --> 00:51:24,225
because there were too many functions to be added or modified

880
00:51:24,225 --> 00:51:26,765
so the cost was too high and it was not implemented

881
00:51:26,765 --> 00:51:31,087
So, the idea we are talking about now, can it help the situation at that time?

882
00:51:31,087 --> 00:51:32,407
So, what would be your answer?

883
00:51:32,407 --> 00:51:33,927
Right, so Subnautica has two problems

884
00:51:44,355 --> 00:51:46,777
that prevented from being multiplayer.

885
00:51:46,777 --> 00:51:50,940
One problem is that it essentially looks like this,

886
00:51:50,940 --> 00:51:52,621
because we didn't know,

887
00:51:52,621 --> 00:51:56,464
like we didn't know about scriptable objects.

888
00:51:56,464 --> 00:51:58,745
We started six years ago with Unity 4,

889
00:51:58,745 --> 00:52:01,287
and there was different Unity,

890
00:52:01,287 --> 00:52:03,969
and we were not experienced with it.

891
00:52:03,969 --> 00:52:05,349
Do you even have scriptable objects?

892
00:52:05,349 --> 00:52:06,650
I think it did.

893
00:52:06,650 --> 00:52:08,171
I think they're really old,

894
00:52:08,171 --> 00:52:10,233
but we didn't know about them.

895
00:52:10,233 --> 00:52:10,793
Right. Right?

896
00:52:13,077 --> 00:52:14,318
所以我們用Singleton在所有地方

897
00:52:14,318 --> 00:52:17,821
基本上所有的Singleton

898
00:52:17,821 --> 00:52:18,301
你都要分開來複製

899
00:52:18,301 --> 00:52:18,982
所以這很難

900
00:52:18,982 --> 00:52:19,122
但是...

901
00:52:19,122 --> 00:52:19,523
你想翻譯嗎?

902
00:52:19,523 --> 00:52:19,563
OK

903
00:52:19,563 --> 00:52:21,104
那就是當時Subnautica確實

904
00:52:21,104 --> 00:52:21,544
他們就是程式架構

905
00:52:21,544 --> 00:52:21,645
當時其實就是長得像這樣

906
00:52:21,645 --> 00:52:21,805
就是寫到後來就是

907
00:52:21,805 --> 00:52:22,605
已經一堆Singleton綁在一起了

908
00:52:22,605 --> 00:52:22,625
那...

909
00:52:40,438 --> 00:52:46,243
他們的遊戲也是只有一個人的玩法

910
00:52:46,243 --> 00:52:49,466
總之當時就考慮說

911
00:52:49,466 --> 00:52:54,169
各種考量之下就沒有辦法去加入兩個人的玩法

912
00:52:54,169 --> 00:52:54,610
成本也太高

913
00:53:10,135 --> 00:53:13,176
You have to stream multiple things.

914
00:53:13,176 --> 00:53:15,197
And that's not very difficult.

915
00:53:15,197 --> 00:53:17,597
If those things are disconnected from each other,

916
00:53:17,597 --> 00:53:19,518
then just everyone has their own world.

917
00:53:19,518 --> 00:53:23,579
But if those players come together and then go away

918
00:53:23,579 --> 00:53:25,620
and then come together again, you

919
00:53:25,620 --> 00:53:27,540
have to somehow synchronize all the data.

920
00:53:27,540 --> 00:53:29,861
And that is a serious rewrite that we didn't want to do.

921
00:53:40,150 --> 00:53:42,111
另外一個當初講到就是

922
00:53:42,111 --> 00:53:43,351
成本太高想要重寫

923
00:53:43,351 --> 00:53:45,172
但沒辦法重寫的部分就是

924
00:53:45,172 --> 00:53:50,034
因為Subnautica它是動態載入

925
00:53:50,034 --> 00:53:52,675
玩家周圍物件跟視野的

926
00:53:52,675 --> 00:53:54,715
就是一般在程式講說

927
00:53:54,715 --> 00:53:56,576
這個叫streaming的技巧

928
00:53:56,576 --> 00:53:58,096
不是視訊串流那個streaming

929
00:53:58,096 --> 00:54:00,617
而是說物件資料的streaming

930
00:54:00,617 --> 00:54:01,878
就是玩家在移動的時候他的

931
00:54:02,707 --> 00:54:04,689
地圖跟物件是慢慢載入的

932
00:54:04,689 --> 00:54:06,291
那一個玩家的時候

933
00:54:06,291 --> 00:54:09,114
他只需要載入那個玩家前面視野

934
00:54:09,114 --> 00:54:10,676
甚至他連玩家背後都不會載入

935
00:54:10,676 --> 00:54:12,958
因為就是會扣掉嘛

936
00:54:12,958 --> 00:54:18,964
那假設兩個玩家同時需要做這件事情的時候

937
00:54:18,964 --> 00:54:21,007
就會有很多很複雜的議題要處理

938
00:54:21,007 --> 00:54:23,269
譬如說這個玩家跟那個玩家同時看到這個物體

939
00:54:23,269 --> 00:54:23,289
那

940
00:54:25,604 --> 00:54:27,185
突然間這兩個玩家離開了

941
00:54:27,185 --> 00:54:28,806
互相對方的視野範圍

942
00:54:28,806 --> 00:54:29,567
那個物體消失了

943
00:54:29,567 --> 00:54:32,189
然後後來這兩個玩家又要重新靠近

944
00:54:32,189 --> 00:54:34,671
那某些物體要一直被移除再載入

945
00:54:34,671 --> 00:54:35,091
那同時要重寫的部分就是太多

946
00:54:35,091 --> 00:54:35,992
所以那個時候就是覺得這邊的處理成本太高

947
00:54:35,992 --> 00:54:36,692
所以也沒有去做

948
00:54:36,692 --> 00:54:38,614
But Subnautica did have

949
00:54:38,614 --> 00:54:38,994
There is a mod

950
00:54:38,994 --> 00:54:40,555
Like a mod that has like two players, right?

951
00:54:40,555 --> 00:54:41,836
Yeah, there is a mod

952
00:54:53,630 --> 00:54:56,913
and it just doesn't deal with the problem.

953
00:54:56,913 --> 00:54:58,695
It just does not synchronize these things.

954
00:54:58,695 --> 00:55:03,220
Yeah, I remember the mod is pretty unstable,

955
00:55:03,220 --> 00:55:06,984
but some people still try to play the game

956
00:55:06,984 --> 00:55:08,566
and stream on Twitch or something.

957
00:55:09,398 --> 00:55:17,382
The parts that are not streamed, for example, the player bases, the submarines, all that stuff,

958
00:55:17,382 --> 00:55:19,583
it does not stream in and out, it's just global.

959
00:55:19,583 --> 00:55:23,025
So that's really easy to synchronize and the mod does that.

960
00:55:23,025 --> 00:55:27,107
And that's already fun because you can drive a submarine

961
00:55:27,107 --> 00:55:30,709
and the other person can be inside the submarine as a passenger.

962
00:55:30,709 --> 00:55:33,190
So that's all good, that works perfectly.

963
00:55:34,028 --> 00:55:38,149
But the mod does not synchronize anything in the world.

964
00:55:38,149 --> 00:55:42,630
So if I pick up a fish, you will still see the fish, right?

965
00:55:42,630 --> 00:55:43,030
Like you have-

966
00:55:43,030 --> 00:55:44,651
You can pick up again, right?

967
00:55:44,651 --> 00:55:45,491
You can pick it up.

968
00:55:45,491 --> 00:55:46,451
For me, it's gone.

969
00:55:46,451 --> 00:55:47,331
Right.

970
00:55:47,331 --> 00:55:49,872
Yeah, so our worlds are just like

971
00:55:49,872 --> 00:55:53,892
different instances of each other, right?

972
00:55:53,892 --> 00:55:58,733
But it's, so basically it works like

973
00:55:58,733 --> 00:56:01,634
both player kind of see each other in their own world.

974
00:56:02,753 --> 00:56:09,297
Yeah, they see each other in their own world and they see the submarine and the bases in their own world.

975
00:56:09,297 --> 00:56:16,021
So there's some amount of data that is shared and then there's a lot of data that is instanced.

976
00:56:16,021 --> 00:56:18,442
And kind of playable.

977
00:56:18,442 --> 00:56:23,905
It's kind of playable and already maybe kind of fun, but it's definitely not something you can ship as a commercial product.

978
00:56:23,905 --> 00:56:24,966
Right.

979
00:56:24,966 --> 00:56:29,769
And so to make it a commercial product would be way more work than that.

980
00:56:31,473 --> 00:56:34,135
就是其實燒中心牆還是有

981
00:56:34,135 --> 00:56:37,098
就是很厲害的玩家去想辦法去把

982
00:56:37,098 --> 00:56:39,280
遊戲模改到可以連線兩個人對玩

983
00:56:39,280 --> 00:56:41,782
就連線對玩 但是

984
00:56:41,782 --> 00:56:43,463
他其實只是有點像是說

985
00:56:43,463 --> 00:56:46,826
因為兩個玩家會各自看到自己的區域嘛

986
00:56:46,826 --> 00:56:49,228
那嚴格上來講其實兩個玩家還是

987
00:56:49,228 --> 00:56:51,430
跑兩個不同版本的

988
00:56:51,430 --> 00:56:52,891
不同實體不同instance

989
00:56:52,891 --> 00:56:53,992
就是不同副本啦

990
00:56:53,992 --> 00:56:56,374
兩個玩家嚴格上來說是在不同副本裡面

991
00:56:56,374 --> 00:56:58,296
但是只是我的玩家的

992
00:56:59,619 --> 00:57:01,520
形狀、外觀跟動作

993
00:57:01,520 --> 00:57:03,421
還有譬如說血量值

994
00:57:03,421 --> 00:57:04,901
有同步

995
00:57:04,901 --> 00:57:07,002
所以我在我的副本裡可以看到你

996
00:57:07,002 --> 00:57:08,943
你在你的副本裡可以看到我

997
00:57:08,943 --> 00:57:11,564
然後有些物體是副本共通的

998
00:57:11,564 --> 00:57:14,265
譬如說整個遊戲裡只有一個載具

999
00:57:14,265 --> 00:57:15,786
那那個載具就是

1000
00:57:15,786 --> 00:57:18,347
兩個人會同時看到同樣載具的位置

1001
00:57:18,347 --> 00:57:20,768
可是如果我今天是譬如說我去撿一個石頭

1002
00:57:20,768 --> 00:57:22,729
那另外一個玩家其實就看不到

1003
00:57:22,729 --> 00:57:24,409
另外一個玩家還是可以看到那個石頭長在那邊

1004
00:57:24,409 --> 00:57:26,870
然後他還可以再重複撿一次

1005
00:57:26,870 --> 00:57:28,491
就基本上他是兩個不同的副本

1006
00:57:29,164 --> 00:57:31,106
所以也是有人魔改成這樣子

1007
00:57:31,106 --> 00:57:32,848
那我想這應該是最簡單的魔改方法

1008
00:57:32,848 --> 00:57:35,470
就是你要傳遞的就只有

1009
00:57:35,470 --> 00:57:35,810
玩家資訊

1010
00:57:35,810 --> 00:57:39,093
然後你要傳遞的就只有

1011
00:57:39,093 --> 00:57:39,674
單獨載具的資訊

1012
00:57:39,674 --> 00:57:42,777
譬如說潛水艇是單獨的

1013
00:57:42,777 --> 00:57:43,998
然後那個快艇小快艇

1014
00:57:43,998 --> 00:57:44,318
還有那個什麼

1015
00:57:44,318 --> 00:57:44,378
那個...

1016
00:57:44,378 --> 00:57:49,863
What's that?

1017
00:57:49,863 --> 00:57:53,006
I didn't know what it was

1018
00:57:53,006 --> 00:57:54,727
然後一些固定的物體

1019
00:57:54,727 --> 00:57:55,568
像那個固定的

1020
00:57:57,914 --> 00:58:00,836
毀壞的飛船是唯一的

1021
00:58:00,836 --> 00:58:02,718
那個東西可以用魔改的方式

1022
00:58:02,718 --> 00:58:03,798
去讓兩個玩家學

1023
00:58:03,798 --> 00:58:07,661
但是兩個玩家真正看到的那些動態物件

1024
00:58:07,661 --> 00:58:12,964
像是魚啊,或是說敵人啊,還是說那個資源

1025
00:58:12,964 --> 00:58:14,325
那個東西是副本狀態

1026
00:58:27,190 --> 00:58:30,712
there's a little bit of world around the player

1027
00:58:30,712 --> 00:58:30,752
uh...

1028
00:58:30,752 --> 00:58:31,893
maybe I can

1029
00:58:31,893 --> 00:58:33,073
kind of like put it side by side

1030
00:58:33,073 --> 00:58:40,997
and as I swim through the world you can kind of see

1031
00:58:40,997 --> 00:58:47,621
new chunks of world coming in and new chunks of world

1032
00:58:47,621 --> 00:58:49,001
fading out

1033
00:58:52,805 --> 00:58:59,971
And so to synchronize everything that's going on in there, everything that has moved, in my instance,

1034
00:58:59,971 --> 00:59:08,498
make that so that Johnson can see it when he comes to visit that same place.

1035
00:59:08,498 --> 00:59:12,421
That is a lot of data.

1036
00:59:12,421 --> 00:59:13,702
So we decided against doing it.

1037
00:59:13,702 --> 00:59:17,164
And there was a third reason, in fact, which is...

1038
00:59:19,219 --> 00:59:28,420
short range science and death science virus is extensive biodiversity and connects to a number of small cave networks

1039
00:59:28,420 --> 00:59:28,580
shut up

1040
00:59:28,580 --> 00:59:35,122
there's a lot about there's a lot about like loneliness and like disbelonging and those kind

1041
00:59:35,122 --> 00:59:42,223
of things and it just doesn't work so well if you have multiplayer because you have your friends

1042
00:59:42,223 --> 00:59:44,043
there you're like doing happy things you're

1043
00:59:44,375 --> 00:59:47,377
You're excited, you're chatting, you're laughing, right?

1044
00:59:47,377 --> 00:59:50,638
That is not really what the game is about.

1045
00:59:50,638 --> 00:59:53,760
So if we wanted to do a multiplayer Subnautica,

1046
00:59:53,760 --> 00:59:59,763
we would have a different gameplay with it.

1047
00:59:59,763 --> 01:00:04,845
That is more about fun, creating things.

1048
01:00:04,845 --> 01:00:07,726
More like in Minecraft, you work together

1049
01:00:07,726 --> 01:00:09,667
in a happy environment, right?

1050
01:00:10,342 --> 01:00:12,582
就是如果你要加另外一個玩家進來的話

1051
01:00:12,582 --> 01:00:14,943
最大的問題其實是

1052
01:00:14,943 --> 01:00:17,144
遊戲設計的部分要幾乎打掉重練

1053
01:00:17,144 --> 01:00:17,504
這個是最大

1054
01:00:17,504 --> 01:00:18,345
這應該是最大的問題

1055
01:00:18,345 --> 01:00:20,765
就是除了剛剛講到的技術困難之外

1056
01:00:20,765 --> 01:00:22,426
像

1057
01:00:22,426 --> 01:00:24,107
其實這個展示應該大家

1058
01:00:24,107 --> 01:00:25,267
不太可能在其他地方看到

1059
01:00:25,267 --> 01:00:26,808
就是實際的這個

1060
01:00:26,808 --> 01:00:31,129
Somnolica編輯器畫面

1061
01:00:31,129 --> 01:00:34,551
然後他如何去stream那個場景跟地形

1062
01:00:34,551 --> 01:00:35,091
可是重點是

1063
01:00:36,289 --> 01:00:40,271
你在故事中就是一個角色在異星球

1064
01:00:40,271 --> 01:00:42,912
然後孤零零的一個人

1065
01:00:42,912 --> 01:00:45,313
然後有很多遊戲中的劇情事件

1066
01:00:45,313 --> 01:00:47,194
是針對一個玩家去設計的

1067
01:00:47,194 --> 01:00:48,914
那如果你有兩個玩家的話

1068
01:00:48,914 --> 01:00:51,095
很多東西會變不make sense

1069
01:00:51,095 --> 01:00:53,596
那你的劇情 你的玩法

1070
01:00:53,596 --> 01:00:56,357
遊戲設計就基本上全部都要怎麼改

1071
01:00:56,357 --> 01:01:00,419
所以理論上要直接做出一個雙人模式

1072
01:01:00,419 --> 01:01:01,419
技術上可能可行

1073
01:01:01,419 --> 01:01:03,340
就是也有 就是剛剛就提到

1074
01:01:03,340 --> 01:01:04,761
就是模組 遊戲模組都做到了

1075
01:01:04,761 --> 01:01:04,921
但是

1076
01:01:05,715 --> 01:01:11,500
在官方的角度來說,這件事情很不合成本效益

1077
01:01:30,844 --> 01:01:38,807
有些遊戲只有在你一個玩家的設定下才有意義

1078
01:01:38,807 --> 01:01:41,508
如果你說像恐怖遊戲

1079
01:01:41,508 --> 01:01:41,728
像剛剛舉的那個

1080
01:01:41,728 --> 01:01:45,729
Friday Night

1081
01:01:45,729 --> 01:01:47,009
就是Freddy's Friday Night

1082
01:01:47,009 --> 01:01:48,670
那個恐怖就是有個熊的

1083
01:01:48,670 --> 01:01:50,951
很可怕的那個熊的遊戲

1084
01:01:50,951 --> 01:01:53,331
像那樣的遊戲你要加散熱模式的話

1085
01:01:53,331 --> 01:01:54,292
那遊戲可能就會變搞笑遊戲

1086
01:01:58,654 --> 01:02:03,098
Okay, so I guess the time is already exactly one hour.

1087
01:02:03,098 --> 01:02:04,078
Yeah, let's call it.

1088
01:02:04,078 --> 01:02:05,760
Yeah, let's call it.

1089
01:02:05,760 --> 01:02:08,822
But I have one final discussion point.

1090
01:02:08,822 --> 01:02:11,625
You can answer it, or you can say this is homework.

1091
01:02:11,625 --> 01:02:13,466
Okay, I also have one final thing.

1092
01:02:13,466 --> 01:02:14,467
Oh, so homework.

1093
01:02:14,467 --> 01:02:21,993
Homework is to actually try this scriptable object approach

1094
01:02:21,993 --> 01:02:24,755
and see where it gives you trouble.

1095
01:02:24,755 --> 01:02:27,738
Because this is not like the answer to everything.

1096
01:02:28,951 --> 01:02:31,633
我想聽聽你的感受

1097
01:02:31,633 --> 01:02:35,096
然後我們再討論這些東西

1098
01:02:35,096 --> 01:02:37,078
所以這是更重要的,我會翻譯

1099
01:02:37,078 --> 01:02:39,539
所以希望大家回去看到這個

1100
01:02:39,539 --> 01:02:40,240
這個實際上

1101
01:02:40,240 --> 01:02:43,823
就是今天都 live demo 結束了

1102
01:02:43,823 --> 01:02:46,545
Jonas 希望各位真的把這個東西

1103
01:02:46,545 --> 01:02:48,366
如果你還沒有用過這樣的技巧的話

1104
01:02:48,366 --> 01:02:50,307
你可以到你的真正的

1105
01:02:50,307 --> 01:02:52,789
現在在開發的專案裡面用看看

1106
01:02:52,789 --> 01:02:54,511
那如果你有遇到任何問題

1107
01:02:54,511 --> 01:02:55,231
就是請直接

1108
01:02:57,206 --> 01:02:58,448
我不知道用什麼方式回報給我

1109
01:02:58,448 --> 01:02:59,809
反正就是

1110
01:02:59,809 --> 01:03:02,793
你可以在任何聯絡的到我們

1111
01:03:02,793 --> 01:03:04,456
兩位任何其中一位的地方

1112
01:03:04,456 --> 01:03:05,497
你就直接提出問題說

1113
01:03:05,497 --> 01:03:08,761
哦我用了script object

1114
01:03:08,761 --> 01:03:10,564
可是我在遊戲裡面

1115
01:03:10,564 --> 01:03:11,745
我在我的程式架構裡面

1116
01:03:11,745 --> 01:03:12,887
因為什麼問題

1117
01:03:12,887 --> 01:03:13,487
我沒有辦法這樣用

1118
01:03:14,205 --> 01:03:16,726
那你實際上用了之後有這樣的具體的

1119
01:03:16,726 --> 01:03:18,706
很具體的問題你提出來的話

1120
01:03:18,706 --> 01:03:19,827
那我們可能就會比較知道說

1121
01:03:19,827 --> 01:03:21,787
API下一堂課要怎麼講

1122
01:03:21,787 --> 01:03:24,468
或是說相關的這些問題是不是其實

1123
01:03:24,468 --> 01:03:29,029
可以把一些可以共通的運用的經驗

1124
01:03:29,029 --> 01:03:30,249
我們再補到那個課程裡面對

1125
01:03:42,449 --> 01:03:47,690
I haven't decided the topic yet. I'm going to do a poll.

1126
01:03:47,690 --> 01:03:53,031
So you can say which topic you want to hear next.

1127
01:03:53,031 --> 01:04:00,433
Next, the workshop we're going to do in January, probably we have to switch our place.

1128
01:04:00,433 --> 01:04:06,774
Because the next month we are going to have the Lunar New Year.

1129
01:04:07,535 --> 01:04:12,677
直接跟隨LunarNear是Global Game Jam

1130
01:04:12,677 --> 01:04:14,258
所以兩個星期基本上都在做

1131
01:04:14,258 --> 01:04:17,080
所以下次的工作室

1132
01:04:17,080 --> 01:04:18,180
你可以投票選項

1133
01:04:18,180 --> 01:04:23,503
現在如果大家有去看Github的Repository的話

1134
01:04:23,503 --> 01:04:26,204
上面其實有一些其他的主題

1135
01:04:26,204 --> 01:04:28,705
Jonas已經把一些草稿

1136
01:04:28,705 --> 01:04:31,407
一些很零碎的想法已經放上去了

1137
01:04:31,407 --> 01:04:34,468
那我們之後會做一個簡單的票選

1138
01:04:34,468 --> 01:04:36,689
就是說希望大家看到下一場要什麼主題

1139
01:04:36,689 --> 01:04:37,050
那就我們

1140
01:04:37,750 --> 01:04:42,814
就是票選完之後我們再來決定下一場要講什麼

1141
01:04:42,814 --> 01:04:45,816
那大概就是從現在到下一場的時間大概是

1142
01:04:45,816 --> 01:04:46,336
大概接近兩個月的時間這樣

