1
00:00:00,969 --> 00:00:07,270
好那我們下半場就請Owen 吳大大

2
00:00:07,270 --> 00:00:14,092
來跟大家介紹ARM現在在對遊戲開發者這邊開始多做一些資源

3
00:00:14,092 --> 00:00:15,072
那請大家掌聲鼓勵

4
00:00:15,072 --> 00:00:20,233
好謝謝

5
00:00:20,233 --> 00:00:21,573
這個有點奇怪

6
00:00:21,573 --> 00:00:22,433
有些人嗎

7
00:00:22,433 --> 00:00:23,573
好謝謝大家

8
00:00:23,573 --> 00:00:26,674
然後

9
00:00:26,674 --> 00:00:27,674
我叫Owen

10
00:00:27,674 --> 00:00:29,835
然後我現在在ARM工作

11
00:00:30,763 --> 00:00:31,883
就是按摩

12
00:00:31,883 --> 00:00:33,985
我不知道你們知道按摩嗎

13
00:00:33,985 --> 00:00:36,986
你應該聽過

14
00:00:36,986 --> 00:00:40,328
上次我們去聯發科的時候

15
00:00:40,328 --> 00:00:41,048
計程車開進去

16
00:00:41,048 --> 00:00:42,049
然後問我們什麼公司

17
00:00:42,049 --> 00:00:42,909
我們說按摩

18
00:00:42,909 --> 00:00:44,030
他說以為

19
00:00:44,030 --> 00:00:46,371
那個門房以為說我們來按摩的

20
00:00:50,488 --> 00:00:53,290
我今天稍微講一下就是

21
00:00:53,290 --> 00:00:55,911
Developer Relations

22
00:00:55,911 --> 00:00:57,092
這個現在在

23
00:00:57,092 --> 00:00:59,534
ARM現在成立了一個部門

24
00:00:59,534 --> 00:01:02,736
然後專門在

25
00:01:02,736 --> 00:01:04,337
針對開發者的關係做一些支援

26
00:01:04,337 --> 00:01:06,739
我等一下講一下

27
00:01:06,739 --> 00:01:08,520
這中間的一些原因

28
00:01:08,520 --> 00:01:10,241
然後還有他做什麼事情

29
00:01:10,241 --> 00:01:10,962
然後再來就

30
00:01:13,535 --> 00:01:15,977
我後來覺得好像有點硬了一點

31
00:01:15,977 --> 00:01:16,938
不過沒關係

32
00:01:16,938 --> 00:01:21,762
反正我會稍微講一下

33
00:01:21,762 --> 00:01:23,424
因為我們ARM其實除了

34
00:01:23,424 --> 00:01:25,165
最有名的是CPU嘛

35
00:01:25,165 --> 00:01:27,007
但其實我們也做GPU

36
00:01:27,007 --> 00:01:29,069
我們GPU是授權給人家去做的

37
00:01:30,801 --> 00:01:32,242
其實實戰率還蠻高的

38
00:01:32,242 --> 00:01:38,026
然後會講一下GPU他Tile Best的Rendering是什麼樣子

39
00:01:38,026 --> 00:01:40,187
其實跟PC是Desktop是不一樣

40
00:01:40,187 --> 00:01:42,589
然後再來是講一個我們的工具

41
00:01:42,589 --> 00:01:45,230
然後因為我們這都是手機的嘛

42
00:01:45,230 --> 00:01:49,013
所以基本上我們只針對手機遊戲在做

43
00:01:49,013 --> 00:01:53,395
所以現在大家是在座各位有開發手機遊戲的嗎?

44
00:01:53,395 --> 00:01:53,716
可以舉一下手嗎?

45
00:02:00,929 --> 00:02:03,191
還有 差不多有一半 還好

46
00:02:03,191 --> 00:02:05,913
那就可以稍微了解一下

47
00:02:05,913 --> 00:02:08,916
那我先講一下說

48
00:02:08,916 --> 00:02:10,197
我們就是剛才講

49
00:02:10,197 --> 00:02:14,361
ARM其實是一家比較特別的公司

50
00:02:14,361 --> 00:02:15,742
我們自己不做晶片

51
00:02:15,742 --> 00:02:17,584
我們只授權IP去給人家做

52
00:02:17,584 --> 00:02:19,946
那我們最近其實

53
00:02:19,946 --> 00:02:21,587
我們以前是

54
00:02:21,587 --> 00:02:23,308
比如說CPU你要做對不對

55
00:02:23,308 --> 00:02:23,729
你要先付

56
00:02:25,020 --> 00:02:26,961
你要先付錢你才能夠

57
00:02:26,961 --> 00:02:27,942
看到一些資料

58
00:02:27,942 --> 00:02:30,023
然後你才可以再去研究說

59
00:02:30,023 --> 00:02:31,164
你想要用哪一顆

60
00:02:31,164 --> 00:02:32,524
我們有很多CPU

61
00:02:32,524 --> 00:02:34,525
你去選你適合你的CPU

62
00:02:34,525 --> 00:02:36,186
然後才付最後的授權費

63
00:02:36,186 --> 00:02:37,347
才能開始在製造

64
00:02:37,347 --> 00:02:38,387
那最近因為

65
00:02:38,387 --> 00:02:39,968
我不知道大家知不知道有

66
00:02:39,968 --> 00:02:41,369
有一個叫

67
00:02:41,369 --> 00:02:42,490
暗示叫做Risk

68
00:02:43,245 --> 00:02:46,848
跟Intel的Cisc是不一樣

69
00:02:46,848 --> 00:02:48,709
它是精簡指令集

70
00:02:48,709 --> 00:02:51,551
那比較適合在Mobile的架構上

71
00:02:51,551 --> 00:02:55,413
可是一直以來精簡指令集大概

72
00:02:55,413 --> 00:02:56,654
就是ON一家獨大

73
00:02:56,654 --> 00:02:59,636
但是現在有一個叫做Risk 5

74
00:02:59,636 --> 00:03:00,877
一個免費的

75
00:03:00,877 --> 00:03:03,339
Open Source的精簡指令集

76
00:03:03,339 --> 00:03:06,801
所以現在為了怕這個東西侵蝕到市場

77
00:03:06,801 --> 00:03:10,083
我們現在低階的CPU都可以

78
00:03:10,083 --> 00:03:10,323
就是

79
00:03:11,579 --> 00:03:14,280
免費的先看說你先給你一些資料

80
00:03:14,280 --> 00:03:16,102
然後你可以去評估你要做哪一個

81
00:03:16,102 --> 00:03:18,743
然後等你要做再付錢

82
00:03:18,743 --> 00:03:22,406
總之我們就是不做實體的晶片

83
00:03:22,406 --> 00:03:27,730
然後只授權像是Apple、Samsung

84
00:03:27,730 --> 00:03:29,891
或仁天堂、Qualcomm這些公司

85
00:03:29,891 --> 00:03:32,873
他們去用我們的IP去做CPU

86
00:03:32,873 --> 00:03:34,154
那我們GPU也是一樣

87
00:03:34,154 --> 00:03:36,075
所以我們GPU也是授權

88
00:03:36,075 --> 00:03:38,297
但現在其實現在市面上手機的

89
00:03:40,262 --> 00:03:43,963
市場上手機的GPU現在只剩Qualcomm

90
00:03:43,963 --> 00:03:44,704
他們自己有

91
00:03:44,704 --> 00:03:47,085
然後再來就是Apple把

92
00:03:47,085 --> 00:03:48,605
PowerVR

93
00:03:48,605 --> 00:03:49,706
也不能就是

94
00:03:49,706 --> 00:03:51,787
其實PowerVR本來就是Apple最大的

95
00:03:51,787 --> 00:03:52,927
Apple是他們最大的股東

96
00:03:52,927 --> 00:03:54,988
所以基本上Apple自己的GPU

97
00:03:54,988 --> 00:03:56,169
然後再下來就是我們的

98
00:03:56,169 --> 00:03:57,849
那只有我們的是

99
00:03:57,849 --> 00:03:58,650
免費售

100
00:03:58,650 --> 00:04:01,731
是有授權的其他都是獨佔的

101
00:04:01,731 --> 00:04:05,993
那所以因為我們本來都沒有在做

102
00:04:05,993 --> 00:04:06,553
做晶片

103
00:04:06,553 --> 00:04:07,733
所以我們不會

104
00:04:07,733 --> 00:04:08,514
之前我們都沒有針對

105
00:04:10,195 --> 00:04:11,856
所謂的終端使用者

106
00:04:11,856 --> 00:04:13,777
就是各位這些開發者

107
00:04:13,777 --> 00:04:14,738
去做support

108
00:04:14,738 --> 00:04:17,099
我們以前只support

109
00:04:17,099 --> 00:04:18,400
晶片廠

110
00:04:18,400 --> 00:04:20,261
可是後來發現

111
00:04:20,261 --> 00:04:21,202
這樣子不大行

112
00:04:21,202 --> 00:04:22,663
因為

113
00:04:22,663 --> 00:04:23,423
到最後會發生問題的都是

114
00:04:26,413 --> 00:04:27,734
都是在遊戲上

115
00:04:27,734 --> 00:04:32,276
但是等他發現問題的時候呢呃

116
00:04:32,276 --> 00:04:33,896
大家就對

117
00:04:33,896 --> 00:04:35,497
對我們的GPU印象不好

118
00:04:35,497 --> 00:04:38,118
所以說我們現在開始

119
00:04:38,118 --> 00:04:40,099
會開始仿效以前

120
00:04:40,099 --> 00:04:41,619
像Desktop

121
00:04:41,619 --> 00:04:43,780
AMD或NVIDIA去support

122
00:04:43,780 --> 00:04:46,001
這些開發者 因為其實我以前是

123
00:04:46,001 --> 00:04:47,782
在AMD工作

124
00:04:47,782 --> 00:04:50,223
也是做一樣的工作 就叫做Developer Relations

125
00:04:50,223 --> 00:04:51,724
那以前我們在AMD的時候

126
00:04:51,724 --> 00:04:53,665
是因為我們直接賣

127
00:04:53,665 --> 00:04:54,105
賣顯示卡

128
00:04:56,135 --> 00:04:58,897
所以我們那時候知道要去

129
00:04:58,897 --> 00:05:00,898
就會直接去support developer

130
00:05:00,898 --> 00:05:04,020
但是

131
00:05:04,020 --> 00:05:04,281
嗯

132
00:05:04,281 --> 00:05:06,882
因為他賣的東西是賣給晶片廠

133
00:05:06,882 --> 00:05:09,104
所以他就沒有去support developer

134
00:05:09,104 --> 00:05:10,045
以前沒有support

135
00:05:10,045 --> 00:05:12,366
那現在開始就是有開始成立這個部門

136
00:05:12,366 --> 00:05:14,088
那就是通常

137
00:05:15,171 --> 00:05:18,272
一般來講很難會在台灣成立這個部門

138
00:05:18,272 --> 00:05:19,953
所以這一次他們在台灣

139
00:05:19,953 --> 00:05:23,975
因為他們在台灣有聯發科這樣的合作夥伴

140
00:05:23,975 --> 00:05:25,616
所以他們在台灣成立這個部門

141
00:05:25,616 --> 00:05:32,979
所以才會有我現在在這個位置上幫助開發者

142
00:05:32,979 --> 00:05:35,140
那我們最主要的

143
00:05:35,140 --> 00:05:36,381
這個部門最主要

144
00:05:36,381 --> 00:05:38,261
這應該是下一段再講

145
00:05:38,261 --> 00:05:39,122
我先講一下這個

146
00:05:39,122 --> 00:05:40,983
那我們現在我們的CPU呢

147
00:05:40,983 --> 00:05:42,944
在這個市場上的Mark share大概是95%

148
00:05:44,725 --> 00:05:46,587
所以幾乎你可以看得到的手機是

149
00:05:46,587 --> 00:05:49,510
Mobile Phone的CPU都是我們的

150
00:05:49,510 --> 00:05:50,390
這個大家都應該知道

151
00:05:50,390 --> 00:05:52,612
但是我們GPU其實也不少

152
00:05:52,612 --> 00:05:56,996
我們GPU在去年就出貨了10億顆

153
00:05:56,996 --> 00:05:59,959
所以其實在市面上大概

154
00:05:59,959 --> 00:06:01,100
市佔率也是蠻高的

155
00:06:01,100 --> 00:06:01,240
所以說呃

156
00:06:02,866 --> 00:06:06,608
如果各位是做手機遊戲開發的話

157
00:06:06,608 --> 00:06:09,230
可能對於我們的GPU叫Mali

158
00:06:09,230 --> 00:06:12,772
Mali的GPU的Support可能也是要花一點心思

159
00:06:12,772 --> 00:06:17,374
不然的話可能在很多機器上是會效能比較不好

160
00:06:17,374 --> 00:06:18,255
那我們這個部門就是

161
00:06:19,437 --> 00:06:21,299
主要的目的 為什麼我們就是

162
00:06:21,299 --> 00:06:23,360
就是我們在support開發者

163
00:06:23,360 --> 00:06:25,102
去把遊戲做

164
00:06:25,102 --> 00:06:27,143
其實主要都是調整performance

165
00:06:27,143 --> 00:06:28,805
然後還有再來就是

166
00:06:28,805 --> 00:06:30,406
看有沒有rendering的問題

167
00:06:30,406 --> 00:06:31,827
那為什麼我們要做這個事情呢

168
00:06:31,827 --> 00:06:33,948
因為這個東西是free的

169
00:06:33,948 --> 00:06:36,270
所以為什麼常常有我去拜訪的時候

170
00:06:36,270 --> 00:06:38,432
大家會問說為什麼我們要

171
00:06:38,432 --> 00:06:40,173
免費幫大家做這些事情呢

172
00:06:40,173 --> 00:06:42,555
因為事實上這個東西就是

173
00:06:42,555 --> 00:06:43,976
一個循環啦

174
00:06:43,976 --> 00:06:44,517
其實我們內部的這個部門

175
00:06:44,517 --> 00:06:44,637
是一個

176
00:06:48,287 --> 00:06:50,409
就是整個環境

177
00:06:50,409 --> 00:06:52,030
要

178
00:06:52,030 --> 00:06:54,432
基本上就是開發者開發的遊戲

179
00:06:54,432 --> 00:06:56,894
在我們的GPU上跑得好

180
00:06:56,894 --> 00:06:59,777
那就會有更多的

181
00:06:59,777 --> 00:07:02,179
晶片製造商來跟我們授權

182
00:07:02,179 --> 00:07:02,939
我們的GPU

183
00:07:02,939 --> 00:07:04,501
那我們的GPU就賣更好

184
00:07:04,501 --> 00:07:07,443
所以說是互相有利的

185
00:07:07,443 --> 00:07:11,226
那我們現在這個部門能做些什麼事情呢

186
00:07:11,226 --> 00:07:14,309
第一個就是我們會做一些Developer的Education

187
00:07:14,309 --> 00:07:17,651
就是教大家怎麼樣在我們的GPU上

188
00:07:18,952 --> 00:07:20,453
我只負責GPU不負責CPU

189
00:07:20,453 --> 00:07:22,154
其實我們CPU也是有人

190
00:07:22,154 --> 00:07:24,275
怎麼樣在我們的GPU上

191
00:07:24,275 --> 00:07:27,237
能夠把效能做到更好

192
00:07:27,237 --> 00:07:29,038
那就像我現在做的事情

193
00:07:29,038 --> 00:07:31,620
就是算是Develop Education

194
00:07:31,620 --> 00:07:32,421
然後再來就是呢

195
00:07:32,421 --> 00:07:33,862
我們有 我們會去查

196
00:07:33,862 --> 00:07:36,183
你們如果以後你們的遊戲

197
00:07:36,183 --> 00:07:37,544
在我們的GPU上

198
00:07:37,544 --> 00:07:39,265
有Rendering的問題

199
00:07:39,265 --> 00:07:40,426
你也可以告訴我

200
00:07:40,426 --> 00:07:42,367
我可以把它丟到Driver Team

201
00:07:42,367 --> 00:07:44,068
去做 去看看到底是

202
00:07:45,959 --> 00:07:47,740
應用程式的問題還是Driver的問題

203
00:07:47,740 --> 00:07:50,842
那如果是Driver的問題我們就會去fix

204
00:07:50,842 --> 00:07:53,264
再來就是Performance的分析

205
00:07:53,264 --> 00:07:54,165
也可以

206
00:07:54,165 --> 00:07:56,047
我們這個部門也可以幫忙

207
00:07:56,047 --> 00:07:56,767
看

208
00:07:56,767 --> 00:07:58,328
然後如果有比較深入的分析

209
00:07:58,328 --> 00:08:01,551
我們主要的部門在UK

210
00:08:01,551 --> 00:08:04,033
就可以把它丟到UK去

211
00:08:04,033 --> 00:08:05,294
去做分析

212
00:08:05,294 --> 00:08:07,155
然後再來就是幫助

213
00:08:07,155 --> 00:08:08,537
開發者去做效能最佳化

214
00:08:08,537 --> 00:08:10,498
這大概是我最主要的工作

215
00:08:10,498 --> 00:08:13,300
就是怎麼樣去幫各位的

216
00:08:13,300 --> 00:08:14,701
手機遊戲做最佳化

217
00:08:15,730 --> 00:08:17,691
然後再來就是

218
00:08:17,691 --> 00:08:20,792
我們現在也開始會有在尋找一些

219
00:08:20,792 --> 00:08:22,053
深入合作的機會

220
00:08:22,053 --> 00:08:24,954
就是說這個手機遊戲跟我們深入合作

221
00:08:24,954 --> 00:08:28,816
專門就是針對Medi GPU去做一些最佳化

222
00:08:28,816 --> 00:08:31,277
那

223
00:08:31,277 --> 00:08:32,417
呃...因為

224
00:08:32,417 --> 00:08:34,578
像以前

225
00:08:34,578 --> 00:08:34,918
呃...我們是

226
00:08:37,291 --> 00:08:39,851
AMD的話自己有出顯卡嘛

227
00:08:39,851 --> 00:08:41,532
以前我們在support developer的時候

228
00:08:41,532 --> 00:08:43,672
我們都會給他們一些顯卡

229
00:08:43,672 --> 00:08:44,652
讓他們去測試

230
00:08:44,652 --> 00:08:47,313
但是因為我們現在沒有辦法

231
00:08:47,313 --> 00:08:48,813
沒有自己做手機

232
00:08:48,813 --> 00:08:52,334
所以很難給開發者手機去測試

233
00:08:52,334 --> 00:08:52,614
但是我們將來

234
00:08:52,614 --> 00:08:52,934
我們現在正在規劃

235
00:08:52,934 --> 00:08:53,074
就是將來我們會

236
00:08:59,181 --> 00:09:02,384
如果有跟我們深度合作的開發者

237
00:09:02,384 --> 00:09:04,746
我們會給他一些手機

238
00:09:04,746 --> 00:09:07,869
用我們的MATIC GPU的手機去做測試

239
00:09:07,869 --> 00:09:09,951
然後再來就是這個深度的合作呢

240
00:09:09,951 --> 00:09:13,193
就是如果我們有做到這個深度的合作

241
00:09:13,193 --> 00:09:15,415
將來就是會有一些機會

242
00:09:15,415 --> 00:09:20,280
在現在在全球的展場上都會有Event

243
00:09:20,773 --> 00:09:23,214
在上面有可能會有合作的展出的機會

244
00:09:23,214 --> 00:09:25,214
像我現在就是在找

245
00:09:25,214 --> 00:09:28,375
就是說有沒有台灣的團隊可以跟我們合作

246
00:09:28,375 --> 00:09:29,816
然後譬如說把他們的手機

247
00:09:29,816 --> 00:09:33,737
的遊戲的performance針對Moddy調整

248
00:09:33,737 --> 00:09:37,158
然後這就可以變成一個story

249
00:09:37,158 --> 00:09:39,419
然後在GDC

250
00:09:39,419 --> 00:09:41,860
我們每年在GDC都有申選

251
00:09:41,860 --> 00:09:44,200
在GDC上面就可以跟

252
00:09:44,200 --> 00:09:46,161
就可以跟這個開發者做一個join申選

253
00:09:46,161 --> 00:09:46,181
說我們

254
00:09:48,262 --> 00:09:50,224
等於有一點幫我們也promote

255
00:09:50,224 --> 00:09:51,765
幫遊戲開發者promote他的遊戲

256
00:09:51,765 --> 00:09:53,366
然後幫我們promote說

257
00:09:53,366 --> 00:09:56,168
我們怎麼樣幫助開發者

258
00:09:56,168 --> 00:09:58,910
然後幫他們把遊戲

259
00:09:58,910 --> 00:10:02,292
做的performance調得更好這樣子

260
00:10:02,292 --> 00:10:04,594
所以這大概就是我們現在

261
00:10:04,594 --> 00:10:06,736
這個ON在

262
00:10:06,736 --> 00:10:09,778
這個開發者關係部門在台灣的工作啦

263
00:10:09,778 --> 00:10:10,478
然後我們有很多

264
00:10:10,478 --> 00:10:12,780
有一些網路上有些資源啦

265
00:10:12,780 --> 00:10:13,421
我們的網站

266
00:10:13,421 --> 00:10:14,321
可是我們的網站其實

267
00:10:16,560 --> 00:10:17,360
對開發者的部分做的

268
00:10:17,360 --> 00:10:18,381
如果你跟NVIDIA比

269
00:10:18,381 --> 00:10:20,723
你就會發現做的有點差

270
00:10:20,723 --> 00:10:22,325
那我們現在就是

271
00:10:22,325 --> 00:10:25,087
一步一步的再往

272
00:10:25,087 --> 00:10:26,569
這方面

273
00:10:26,569 --> 00:10:28,330
對於開發者的支援更好

274
00:10:28,330 --> 00:10:30,012
這方面走

275
00:10:30,012 --> 00:10:32,915
OK 那就

276
00:10:32,915 --> 00:10:34,476
感覺後面接下來就會

277
00:10:34,476 --> 00:10:36,638
比較硬一點

278
00:10:36,638 --> 00:10:38,620
那我們就講一下這個GPU

279
00:10:38,620 --> 00:10:38,640
因為

280
00:10:40,399 --> 00:10:42,540
這個是 我今天其實是挑過啦

281
00:10:42,540 --> 00:10:45,320
講一些比較 general 的東西啦

282
00:10:45,320 --> 00:10:47,421
那這個是我覺得比較重要的

283
00:10:47,421 --> 00:10:51,622
就是說其實有很多從 PC 轉過來的開發者

284
00:10:51,622 --> 00:10:54,263
其實並不了解 GPU

285
00:10:54,263 --> 00:10:57,103
Mobile GPU 跟 Desktop GPU

286
00:10:57,103 --> 00:10:59,184
其實是有滿大的不同的

287
00:10:59,184 --> 00:11:00,624
因為現在的 Mobile 的主流

288
00:11:00,624 --> 00:11:02,085
就是用 Tile Best 的 Rendering

289
00:11:02,085 --> 00:11:04,485
我不知道大家知不知道 NVIDIA 有一顆 Tegra

290
00:11:05,025 --> 00:11:06,786
就是現在用在Switch上面的

291
00:11:06,786 --> 00:11:08,907
那它 因為它就不是Tile Base

292
00:11:08,907 --> 00:11:12,929
它大概是唯一一顆不是Tile Base的Mobile GPU

293
00:11:12,929 --> 00:11:15,910
所以它當初的耗電量一直是一個很大的問題

294
00:11:15,910 --> 00:11:18,412
所以它最後就退出市場

295
00:11:18,412 --> 00:11:22,513
因為在手機上面耗電量是一個很重要的事情

296
00:11:22,513 --> 00:11:28,556
那Tile Base就是一個跟Desktop完全不同的設計

297
00:11:28,556 --> 00:11:30,517
那主要的目的就是在於省電

298
00:11:30,517 --> 00:11:32,178
OK

299
00:11:32,178 --> 00:11:33,478
那 OK

300
00:11:34,412 --> 00:11:36,433
所以現在我們先看一下

301
00:11:36,433 --> 00:11:39,234
這個就是傳統的GPU的做法

302
00:11:39,234 --> 00:11:41,855
我們稱它叫做Immediate Mode

303
00:11:41,855 --> 00:11:43,595
所以基本上你可以看到

304
00:11:43,595 --> 00:11:45,936
你是一個Render Path裡面

305
00:11:45,936 --> 00:11:48,597
你所有的Primitive是執行完

306
00:11:48,597 --> 00:11:49,818
Vertex Shader以後

307
00:11:49,818 --> 00:11:52,379
這個Primitive執行完

308
00:11:52,379 --> 00:11:53,119
Vertex Shader以後

309
00:11:53,119 --> 00:11:56,300
就直接執行Fragment Shader

310
00:11:56,300 --> 00:11:58,421
所以是

311
00:11:58,421 --> 00:11:59,301
一個一個Primitive去畫的

312
00:11:59,301 --> 00:12:00,321
慢慢一個一個Primitive去畫出來的

313
00:12:00,321 --> 00:12:02,382
慢慢一個一個Primitive去畫出來的

314
00:12:04,241 --> 00:12:09,143
可是這個是他在GPU上面的一個流程

315
00:12:09,143 --> 00:12:12,005
那你可以看到

316
00:12:12,005 --> 00:12:15,447
中間有一個地方就是這裡

317
00:12:15,447 --> 00:12:16,887
這裡是

318
00:12:16,887 --> 00:12:18,228
因為如果照原來這種

319
00:12:18,228 --> 00:12:21,329
Immediate Mode的模式去做的時候

320
00:12:21,329 --> 00:12:22,430
在Fragment Share的時候

321
00:12:22,430 --> 00:12:24,571
他要頻繁的去存取

322
00:12:24,571 --> 00:12:25,571
所謂的外部GDP

323
00:12:26,620 --> 00:12:31,642
那存取記憶體其實是在手機上是一個最耗電的行為

324
00:12:31,642 --> 00:12:33,062
而且又慢

325
00:12:33,062 --> 00:12:37,603
手機上的通常的記憶體的頻寬是遠低於Desktop的

326
00:12:37,603 --> 00:12:41,844
所以這個做法在手機上會行不通

327
00:12:41,844 --> 00:12:46,605
所以TileBase就把它改掉了

328
00:12:46,605 --> 00:12:50,166
它主要的目的就是說減少外部記憶體的存取

329
00:12:51,387 --> 00:12:53,047
那他用的做法呢

330
00:12:53,047 --> 00:12:55,409
就是每一次處理一個畫面上的一個Tile

331
00:12:55,409 --> 00:12:58,890
一個Tile就是16x16的一個區域

332
00:12:58,890 --> 00:13:00,531
他每次就只處理這個Tile

333
00:13:00,531 --> 00:13:02,672
一個一個Tile的去把畫面做完

334
00:13:02,672 --> 00:13:04,953
而不是像Immediate Mode的

335
00:13:04,953 --> 00:13:06,954
Desktop的GPU是

336
00:13:06,954 --> 00:13:09,735
一個一個Primitive去把它處理完

337
00:13:09,735 --> 00:13:12,897
他是把所有的Primitive收集好

338
00:13:12,897 --> 00:13:14,638
然後看他

339
00:13:14,638 --> 00:13:17,579
然後看這個Tile裡面有多少個Primitive

340
00:13:18,492 --> 00:13:19,552
處理一個Tile這樣子

341
00:13:19,552 --> 00:13:21,113
那它的目的呢

342
00:13:21,113 --> 00:13:23,233
就是要減少記憶體的存取

343
00:13:23,233 --> 00:13:25,834
所以說在Tile-based的GPU上面

344
00:13:25,834 --> 00:13:32,117
其實你去

345
00:13:32,117 --> 00:13:33,237
你雖然是

346
00:13:33,237 --> 00:13:34,317
如果你是用OpenGL

347
00:13:34,317 --> 00:13:36,618
你去說做Primitive

348
00:13:36,618 --> 00:13:37,859
畫三角形畫三角形

349
00:13:37,859 --> 00:13:39,259
可是事實上到了Drivers

350
00:13:39,259 --> 00:13:41,540
它是會把你拆開的

351
00:13:41,540 --> 00:13:43,221
集合起來再拆開

352
00:13:43,221 --> 00:13:45,221
然後它有一定的規則啦

353
00:13:45,221 --> 00:13:46,362
但是它基本上

354
00:13:46,362 --> 00:13:47,102
就會把它做成

355
00:13:47,999 --> 00:13:49,079
一群一群的處理

356
00:13:49,079 --> 00:13:50,680
那每一群的話

357
00:13:50,680 --> 00:13:53,461
他要把它分成兩個Path來處理

358
00:13:53,461 --> 00:13:54,681
第一個是Vertex Path

359
00:13:54,681 --> 00:13:56,902
第二個是Fragment Path

360
00:13:56,902 --> 00:13:58,142
那剛剛可以看到那個Desktop

361
00:13:58,142 --> 00:13:59,123
是沒有這樣的處理

362
00:13:59,123 --> 00:14:01,804
它直接你要它畫畫

363
00:14:01,804 --> 00:14:02,884
硬體就直接幫你畫出來

364
00:14:02,884 --> 00:14:04,565
所以它才叫Immediate Mode

365
00:14:04,565 --> 00:14:06,985
所以說在Tile的GPU上面

366
00:14:06,985 --> 00:14:08,846
它就

367
00:14:08,846 --> 00:14:10,207
第一個它是做Vertex

368
00:14:10,207 --> 00:14:12,527
Vertex的處理

369
00:14:12,527 --> 00:14:14,568
它必須把你所有的

370
00:14:14,568 --> 00:14:15,668
這一個Render Path裡面

371
00:14:16,621 --> 00:14:19,342
所有的 vertex 都處理完

372
00:14:19,342 --> 00:14:24,804
然後放到一個叫做 polygon list 裡面

373
00:14:24,804 --> 00:14:26,665
然後這個東西呢

374
00:14:26,665 --> 00:14:28,746
這個問題就在於這個東西它要存取

375
00:14:28,746 --> 00:14:30,386
要存到外部的記憶體

376
00:14:30,386 --> 00:14:36,228
所以這裡會造成一個記憶體的損失

377
00:14:36,228 --> 00:14:37,769
記憶體的那個流量的要求啦

378
00:14:37,769 --> 00:14:37,909
就是

379
00:14:38,931 --> 00:14:41,352
他會去存取外部記憶體

380
00:14:41,352 --> 00:14:43,574
這邊就是跟desktop不大一樣

381
00:14:43,574 --> 00:14:44,854
像比如說

382
00:14:44,854 --> 00:14:47,376
像我們一般在做desktop的時候

383
00:14:47,376 --> 00:14:50,398
我們現在很流行的做法是

384
00:14:50,398 --> 00:14:52,079
先做pre-zpass

385
00:14:52,079 --> 00:14:53,459
然後再來做render

386
00:14:53,459 --> 00:14:55,541
但是這個做法到了mobile GPU上

387
00:14:55,541 --> 00:14:57,762
可能就反而會得到反效果了

388
00:14:57,762 --> 00:14:59,903
因為你第一個pass的時候

389
00:14:59,903 --> 00:15:01,584
你就要把所有的particle的資料

390
00:15:01,584 --> 00:15:03,965
全部寫到外部記憶體

391
00:15:03,965 --> 00:15:04,266
然後再讀回來

392
00:15:05,462 --> 00:15:07,922
然後第二次又要再寫一次再讀回來

393
00:15:07,922 --> 00:15:10,923
那這就違反了在Mobile上面Performance的原則

394
00:15:10,923 --> 00:15:14,183
Mobile上面Performance的原則就是

395
00:15:14,183 --> 00:15:17,124
越少的記憶體流量是越好的

396
00:15:17,124 --> 00:15:19,164
你就會越省電而且越快

397
00:15:19,164 --> 00:15:24,765
然後再來就是等你把所有的

398
00:15:24,765 --> 00:15:28,326
這個Path裡面的所有的Punitive的端點都處理完

399
00:15:28,326 --> 00:15:30,086
把它寫到一個List以後呢

400
00:15:30,086 --> 00:15:34,227
它才全部的一次丟到Fragment去做FragmentShader

401
00:15:34,953 --> 00:15:37,295
那它的流程會變成是這個樣子

402
00:15:37,295 --> 00:15:38,696
你可以看到說

403
00:15:38,696 --> 00:15:40,798
它這邊

404
00:15:40,798 --> 00:15:42,499
這邊會有一個外部記憶體的存取

405
00:15:42,499 --> 00:15:44,241
就是我剛才講的那個

406
00:15:44,241 --> 00:15:46,723
那個list list會寫到

407
00:15:46,723 --> 00:15:47,984
寫到外面的記憶體

408
00:15:47,984 --> 00:15:51,006
然後其實它還會再讀回來啦

409
00:15:51,006 --> 00:15:53,388
它右邊那個就是在讀回來

410
00:15:53,388 --> 00:15:55,970
然後你可以看到在fragment shader的時候

411
00:15:55,970 --> 00:15:57,011
因為它是一個一個

412
00:15:57,011 --> 00:15:58,392
一個tile一個tile處理

413
00:15:58,392 --> 00:15:59,753
所以每一個tile其實它會有

414
00:15:59,753 --> 00:15:59,813
一塊記憶體

415
00:15:59,813 --> 00:16:01,175
所以你就可以看到

416
00:16:01,175 --> 00:16:01,215
它會寫到

417
00:16:01,215 --> 00:16:01,235
寫到

418
00:16:01,235 --> 00:16:01,255
寫到

419
00:16:01,255 --> 00:16:01,275
寫到

420
00:16:01,275 --> 00:16:01,295
寫到

421
00:16:01,295 --> 00:16:01,315
寫到

422
00:16:01,315 --> 00:16:01,355
寫到

423
00:16:01,355 --> 00:16:01,495
寫到

424
00:16:01,495 --> 00:16:01,635
寫到

425
00:16:01,635 --> 00:16:02,496
寫到

426
00:16:02,496 --> 00:16:02,576
寫到

427
00:16:02,576 --> 00:16:02,716
寫到

428
00:16:02,716 --> 00:16:02,736
寫到

429
00:16:04,444 --> 00:16:06,266
在晶片裡面的

430
00:16:06,266 --> 00:16:08,227
它小小的但是

431
00:16:08,227 --> 00:16:12,851
足夠容納這16x16的pixel的data

432
00:16:12,851 --> 00:16:15,393
那這塊記憶體它是在晶片裡面的

433
00:16:15,393 --> 00:16:16,894
所以它的速度很快也很省電

434
00:16:16,894 --> 00:16:20,117
那你可以看到大部分的記憶體的

435
00:16:20,117 --> 00:16:22,419
記憶體的流量都是發生在這裡

436
00:16:22,419 --> 00:16:24,180
那這樣子它就

437
00:16:24,180 --> 00:16:25,341
達到它的省電跟

438
00:16:25,341 --> 00:16:31,066
performance的目的了

439
00:16:31,066 --> 00:16:32,967
然後剛剛有講到render pass嗎

440
00:16:32,967 --> 00:16:33,207
就是我說

441
00:16:36,199 --> 00:16:38,792
雖然我們用OpenGL叫他畫什麼畫什麼畫什麼

442
00:16:40,482 --> 00:16:43,483
可是事實上在Tile GPU的話

443
00:16:43,483 --> 00:16:46,405
他都必須把它拆成好幾個Render Pass

444
00:16:46,405 --> 00:16:48,186
如果你只有一個Frame Buffer

445
00:16:48,186 --> 00:16:50,507
你一次就是全部都Render到這個Frame Buffer上

446
00:16:50,507 --> 00:16:52,268
那你可能就會只有

447
00:16:52,268 --> 00:16:53,989
你就只會有一個Render Pass

448
00:16:53,989 --> 00:16:54,789
可能啦

449
00:16:54,789 --> 00:16:55,990
就會只有一個Render Pass

450
00:16:55,990 --> 00:16:57,631
但是如果你一直

451
00:16:57,631 --> 00:16:59,672
你有切換Frame Buffer

452
00:16:59,672 --> 00:17:01,933
他就會被它拆成好幾個Render Pass

453
00:17:01,933 --> 00:17:05,815
然後在某些情況下也會被拆成很多Render Pass

454
00:17:05,815 --> 00:17:07,476
當然你Render Pass越多

455
00:17:07,476 --> 00:17:09,157
你的效能就會越差

456
00:17:09,157 --> 00:17:09,177
那

457
00:17:10,280 --> 00:17:15,943
比較麻煩的是從API的level來看

458
00:17:15,943 --> 00:17:19,165
你是完全看不出來

459
00:17:19,165 --> 00:17:21,726
幾乎完全看不出來

460
00:17:21,726 --> 00:17:26,168
你的整個render這個frame被拆成多少個render paths

461
00:17:26,168 --> 00:17:29,190
所以你必須要用一些工具

462
00:17:29,190 --> 00:17:32,952
後面我們會提到我們有提供一些工具可以去看

463
00:17:32,952 --> 00:17:34,433
但是基本上的原則就是

464
00:17:35,764 --> 00:17:38,625
不要頻繁的去換frame buffer

465
00:17:38,625 --> 00:17:41,646
如果你frame buffer一直頻繁的在切換的話

466
00:17:41,646 --> 00:17:45,467
他就會造成很多的render pass

467
00:17:45,467 --> 00:17:46,868
然後

468
00:17:46,868 --> 00:17:50,029
我們剛才講到GPU會先有vertical pass

469
00:17:50,029 --> 00:17:53,030
vertical pass其實他的原理是這樣子

470
00:17:53,030 --> 00:17:55,150
就是說你這邊

471
00:17:55,150 --> 00:17:56,131
我的

472
00:17:56,131 --> 00:17:56,831
不要這樣子

473
00:17:56,831 --> 00:17:58,051
就是說

474
00:17:58,051 --> 00:18:00,052
你現在如果要開始

475
00:18:00,052 --> 00:18:01,792
丟一個primitive進來畫的時候

476
00:18:01,792 --> 00:18:03,053
他第一步是先做完

477
00:18:04,199 --> 00:18:05,440
Position的Shading

478
00:18:05,440 --> 00:18:07,381
就是把它的呃

479
00:18:07,381 --> 00:18:09,243
就是執行你的Vertex Shader

480
00:18:09,243 --> 00:18:10,604
然後呢

481
00:18:10,604 --> 00:18:12,786
它開始會做了一些Cooling

482
00:18:12,786 --> 00:18:15,088
在 這都是在GPU裡面做的事情

483
00:18:15,088 --> 00:18:16,009
Hotwheel做的事情

484
00:18:16,009 --> 00:18:17,711
它會把你的

485
00:18:17,711 --> 00:18:20,373
先把你呃

486
00:18:20,373 --> 00:18:21,234
背面的

487
00:18:21,234 --> 00:18:22,275
背面的

488
00:18:22,275 --> 00:18:24,356
的這些Triangle都Cool掉

489
00:18:24,356 --> 00:18:25,077
然後接下來

490
00:18:25,077 --> 00:18:27,559
它會再進入所謂的Frosten Cooling

491
00:18:27,559 --> 00:18:29,381
只要你不在Viewport裡面的東西

492
00:18:29,381 --> 00:18:30,622
它都會再把你Cool掉

493
00:18:31,840 --> 00:18:35,944
然後最後他會做一個Sample-Tested Culling

494
00:18:35,944 --> 00:18:37,005
這個可能你們比較不知道

495
00:18:37,005 --> 00:18:40,488
就是說當你的Triangle小於一個Pixel的時候

496
00:18:40,488 --> 00:18:42,990
他就會幫你把它Cull掉

497
00:18:42,990 --> 00:18:45,873
然後呢這個做完了這些以後呢

498
00:18:45,873 --> 00:18:46,834
才會進入到

499
00:18:46,834 --> 00:18:48,155
這是我們硬體的一個特性

500
00:18:48,155 --> 00:18:49,776
就是說他一開始的Vertex Shader

501
00:18:49,776 --> 00:18:52,139
他會把你的Vertex Shader切成兩個部分

502
00:18:52,139 --> 00:18:54,701
一部分只跟Position有關

503
00:18:54,701 --> 00:18:55,121
他先做

504
00:18:56,180 --> 00:18:59,624
然後他把該庫額掉的都庫額掉以後呢

505
00:18:59,624 --> 00:19:02,488
才做接下來其他的attribute

506
00:19:02,488 --> 00:19:04,471
vertical mean attribute的計算

507
00:19:04,471 --> 00:19:06,894
這樣就可以省掉很多

508
00:19:06,894 --> 00:19:08,356
對於這些看不見的點的

509
00:19:10,208 --> 00:19:11,629
shader的運算時間

510
00:19:11,629 --> 00:19:14,010
然後最後他會寫到一個外部記憶體

511
00:19:14,010 --> 00:19:15,331
就把這些所有的

512
00:19:15,331 --> 00:19:17,833
particle都寫進去 然後接下來

513
00:19:17,833 --> 00:19:19,774
他就要執行fragment shader

514
00:19:19,774 --> 00:19:22,236
那這個list裡面有很多個

515
00:19:22,236 --> 00:19:23,737
primitive 我現在只用一個

516
00:19:23,737 --> 00:19:24,717
來代表 他會先經過

517
00:19:24,717 --> 00:19:26,198
resolizer

518
00:19:26,198 --> 00:19:30,821
resolizer呢 他就會把它換成

519
00:19:30,821 --> 00:19:31,782
把一個particle

520
00:19:31,782 --> 00:19:33,683
換成螢幕上的很多個

521
00:19:33,683 --> 00:19:35,524
quad

522
00:19:35,524 --> 00:19:37,806
我們叫quad 因為一個quad裡面有4個pixel

523
00:19:38,915 --> 00:19:41,555
然後呢 這個Quad會經過

524
00:19:41,555 --> 00:19:42,215
這邊蠻重要的就是說

525
00:19:42,215 --> 00:19:46,336
他會先經過一個叫RZZ的Test

526
00:19:46,336 --> 00:19:48,437
所以說

527
00:19:48,437 --> 00:19:51,457
這邊就是一個可以節省你的

528
00:19:51,457 --> 00:19:53,038
可以增進你Performance的地方

529
00:19:53,038 --> 00:19:55,438
就是說 如果你的

530
00:19:55,438 --> 00:19:57,199
你能夠讓你的這個

531
00:19:57,199 --> 00:20:00,039
Primitive呢

532
00:20:00,039 --> 00:20:02,220
盡量在這個地方就先被剔除掉

533
00:20:02,220 --> 00:20:04,440
他就不會再去執行後面的

534
00:20:04,440 --> 00:20:04,980
這些Shader

535
00:20:04,980 --> 00:20:07,021
比較Expensive的Shader的動作

536
00:20:08,095 --> 00:20:10,335
在什麼情況下他會做這些

537
00:20:10,335 --> 00:20:13,816
應該說在什麼情況下他沒辦法做Early Test

538
00:20:13,816 --> 00:20:17,777
這就是說如果你用了

539
00:20:17,777 --> 00:20:20,718
這個Discard這個指令

540
00:20:20,718 --> 00:20:26,020
因為他一定要執行完學者談才能知道可不可以被責斃掉

541
00:20:26,020 --> 00:20:29,841
然後或者你用了Alpha to Coverage這些東西的話

542
00:20:29,841 --> 00:20:34,402
或者你用了Alpha Blending就是沒有辦法被做Early Test

543
00:20:35,267 --> 00:20:37,328
然後呢 它做完RZZ以後

544
00:20:37,328 --> 00:20:39,030
它就會把該

545
00:20:39,030 --> 00:20:39,990
會被遮住的

546
00:20:39,990 --> 00:20:41,211
它現在已經可以判斷說

547
00:20:41,211 --> 00:20:43,133
啊有這些

548
00:20:43,133 --> 00:20:44,554
有些pixel

549
00:20:44,554 --> 00:20:46,716
有些quad是一定會被遮住的

550
00:20:46,716 --> 00:20:48,437
它就會先把它

551
00:20:48,437 --> 00:20:49,418
就把它排除掉了

552
00:20:49,418 --> 00:20:52,020
然後接下來的剛剛這邊

553
00:20:52,020 --> 00:20:54,501
接下來有能夠成功活下來的

554
00:20:54,501 --> 00:20:55,362
就會

555
00:20:55,362 --> 00:20:57,384
我們的硬體就會把它變成

556
00:20:57,384 --> 00:20:58,825
四個pixel

557
00:20:58,825 --> 00:20:59,706
這個四個pixel呢

558
00:20:59,706 --> 00:21:01,047
開始就丟到

559
00:21:01,047 --> 00:21:01,707
就是我們的

560
00:21:02,618 --> 00:21:05,159
GPU的Engine裡面去做Shader的計算

561
00:21:05,159 --> 00:21:08,080
做完Shader的計算以後呢

562
00:21:08,080 --> 00:21:09,801
才會做LaterZ

563
00:21:09,801 --> 00:21:11,902
那我們在做Performance

564
00:21:11,902 --> 00:21:13,142
在調整Performance的時候

565
00:21:13,142 --> 00:21:15,543
就是盡量要讓你的東西

566
00:21:15,543 --> 00:21:17,184
在LaterZ就被庫爾掉

567
00:21:17,184 --> 00:21:18,805
不要到LaterZ才去

568
00:21:18,805 --> 00:21:20,746
因為到LaterZ的時候常常就是說

569
00:21:20,746 --> 00:21:23,847
你耗費了FragmentShader

570
00:21:23,847 --> 00:21:25,107
做了很多運算以後

571
00:21:25,107 --> 00:21:26,988
然後發現他根本看不到

572
00:21:26,988 --> 00:21:28,409
那就浪費了

573
00:21:28,409 --> 00:21:30,069
那他如果在這邊才發現

574
00:21:30,069 --> 00:21:31,870
那你到LaterZ的時候才把他庫爾掉

575
00:21:33,550 --> 00:21:35,671
那如果他沒有被遮到

576
00:21:35,671 --> 00:21:37,911
他就會把它

577
00:21:37,911 --> 00:21:38,392
運算完

578
00:21:38,392 --> 00:21:39,272
運算完以後呢

579
00:21:39,272 --> 00:21:41,373
我們有做Blending嘛

580
00:21:41,373 --> 00:21:43,194
Blending其實是一個

581
00:21:43,194 --> 00:21:46,275
做在硬體裡面固定的一個function的一個硬體

582
00:21:46,275 --> 00:21:47,435
然後他就把它

583
00:21:47,435 --> 00:21:50,196
跟Tile Base裡面的

584
00:21:50,196 --> 00:21:53,377
資料做Blending

585
00:21:53,377 --> 00:21:54,838
那這個Tile Base

586
00:21:54,838 --> 00:21:55,758
Tile Memory呢

587
00:21:55,758 --> 00:21:58,039
Tile Memory是在Chip裡面的

588
00:21:58,039 --> 00:21:58,800
所以他速度很快

589
00:22:00,735 --> 00:22:02,637
但是他的大小就是一個Tile的大小

590
00:22:02,637 --> 00:22:04,318
然後他把每一個Pixel

591
00:22:04,318 --> 00:22:06,800
這個Tile裡面每一個Pixel

592
00:22:06,800 --> 00:22:08,462
都處理完了以後呢

593
00:22:08,462 --> 00:22:10,503
他就一次的

594
00:22:10,503 --> 00:22:12,765
把他這個Tile直接寫到

595
00:22:12,765 --> 00:22:13,846
外部記憶體

596
00:22:13,846 --> 00:22:16,568
然後就這樣一個一個一個一個Tile把它處理完

597
00:22:16,568 --> 00:22:18,650
就是整個畫面處理完了

598
00:22:18,650 --> 00:22:20,671
那剛剛你可以看到這個Tile

599
00:22:20,671 --> 00:22:22,373
Tile Memory

600
00:22:22,373 --> 00:22:23,874
所以就是問題就來了

601
00:22:23,874 --> 00:22:27,797
Tile Memory在每一次每一個Render Pass

602
00:22:27,797 --> 00:22:28,998
開始的時候他必須

603
00:22:28,998 --> 00:22:29,358
從外部的記憶體把

604
00:22:31,482 --> 00:22:34,383
把這個Friend的Data讀進來

605
00:22:34,383 --> 00:22:36,323
他才知道上一個Friend是什麼嘛

606
00:22:36,323 --> 00:22:38,444
然後開始畫了以後

607
00:22:38,444 --> 00:22:39,164
開始做Blending

608
00:22:39,164 --> 00:22:40,525
Blending完了以後

609
00:22:40,525 --> 00:22:42,845
這個Tile處理完再寫回去

610
00:22:42,845 --> 00:22:43,806
所以這邊呢

611
00:22:43,806 --> 00:22:46,186
這邊就是要存取到外部記憶體

612
00:22:46,186 --> 00:22:47,807
那這部分也是一個

613
00:22:47,807 --> 00:22:51,308
Optimization的技巧就是

614
00:22:51,308 --> 00:22:52,528
譬如說像很多

615
00:22:52,528 --> 00:22:53,709
常常你在Render的時候

616
00:22:53,709 --> 00:22:54,329
你一開始是

617
00:22:55,427 --> 00:22:56,488
整個螢幕Clear掉

618
00:22:56,488 --> 00:22:58,549
你根本不在乎前一個畫面的時候

619
00:22:58,549 --> 00:23:01,831
你就必須要告訴硬體

620
00:23:01,831 --> 00:23:03,992
說我不在乎前面的畫面

621
00:23:03,992 --> 00:23:06,673
所以它就不會從外部機器把東西堵進來

622
00:23:06,673 --> 00:23:10,695
它的Tile Memory就做一個很快的Initialization

623
00:23:10,695 --> 00:23:11,976
那寫出去的時候也是一樣

624
00:23:11,976 --> 00:23:13,517
如果你

625
00:23:13,517 --> 00:23:14,818
你根本不需要寫出去

626
00:23:14,818 --> 00:23:18,900
譬如說你只有做Shadow Map的Rendering

627
00:23:18,900 --> 00:23:21,081
這樣你就不需要寫到Color Buffer

628
00:23:21,081 --> 00:23:21,841
那你把它

629
00:23:23,624 --> 00:23:26,545
告訴那個API說你不需要寫出去

630
00:23:26,545 --> 00:23:28,625
它就不會把它寫到外部記憶體

631
00:23:28,625 --> 00:23:31,706
那這個就是在Mobile上面一個

632
00:23:31,706 --> 00:23:35,527
基本上來講是一個最重要的performance的技巧

633
00:23:35,527 --> 00:23:37,447
那這邊就是我剛才講的

634
00:23:37,447 --> 00:23:43,449
所以它基本上在Mobile上面就是你要盡量的去避免

635
00:23:43,449 --> 00:23:47,670
這個每一個Render Pass的Frame Buff外部記憶體的存取啦

636
00:23:49,144 --> 00:23:52,005
好 那我們就講一下後面

637
00:23:52,005 --> 00:23:54,607
這邊 剛剛前面講的就是一個

638
00:23:54,607 --> 00:23:56,568
呃 我發現比較多人不知道的啦

639
00:23:56,568 --> 00:23:58,329
尤其是從PC轉過來以後

640
00:23:58,329 --> 00:24:00,590
比較不知道的一個地方

641
00:24:00,590 --> 00:24:02,931
那 再來就是我們

642
00:24:02,931 --> 00:24:04,292
今年3月的時候

643
00:24:04,292 --> 00:24:05,973
在GTC的時候推出這個產品

644
00:24:05,973 --> 00:24:07,274
那這是第一代

645
00:24:07,274 --> 00:24:12,397
所以 呃 還不是功能還不是很好

646
00:24:12,397 --> 00:24:13,657
應該說還是有蠻多問題的啦

647
00:24:13,657 --> 00:24:16,179
但是基本上 如果你會使用它的話

648
00:24:16,179 --> 00:24:16,719
其實你可以

649
00:24:17,656 --> 00:24:19,577
把你的Performance調到很好

650
00:24:19,577 --> 00:24:21,497
你可以看到很多硬體的數據

651
00:24:21,497 --> 00:24:25,178
那基本上他是會由四個東西組成

652
00:24:25,178 --> 00:24:27,079
一個叫Streamline

653
00:24:27,079 --> 00:24:29,520
一個叫做Graphic Analyzer

654
00:24:29,520 --> 00:24:32,181
然後一個是Shader的Offline Compiler

655
00:24:32,181 --> 00:24:34,382
然後最後一個叫做Performance Advisor

656
00:24:35,155 --> 00:24:36,576
那我一個一個講一下

657
00:24:36,576 --> 00:24:37,417
很快速的講一下

658
00:24:37,417 --> 00:24:38,938
所謂Streamline就是

659
00:24:38,938 --> 00:24:43,662
我不知道大家在寫軟體的時候

660
00:24:43,662 --> 00:24:46,163
我們常常會用一些Counter

661
00:24:46,163 --> 00:24:48,105
來做一些計數

662
00:24:48,105 --> 00:24:50,426
比如說畫了多少個Primitive

663
00:24:50,426 --> 00:24:52,088
或處理了多少個點

664
00:24:52,088 --> 00:24:53,389
其實在硬體裡面也有

665
00:24:53,389 --> 00:24:54,770
但是做在硬體裡面的

666
00:24:54,770 --> 00:24:56,751
所以這個Streamline就是

667
00:24:56,751 --> 00:24:58,773
可以把硬體裡面的Counter讀出來

668
00:24:59,782 --> 00:25:02,303
那他可以告訴你很多很細節的資料

669
00:25:02,303 --> 00:25:04,204
像我們剛才講的Rez

670
00:25:04,204 --> 00:25:07,085
有多少pixel有做Rez

671
00:25:07,085 --> 00:25:08,766
有多少pixel沒做

672
00:25:08,766 --> 00:25:09,767
你都可以知道

673
00:25:09,767 --> 00:25:13,928
不然的話其實他在硬體裡面發生你都不知道

674
00:25:13,928 --> 00:25:17,970
那他也可以告訴你的CPU現在的

675
00:25:17,970 --> 00:25:18,850
cycle數是多少

676
00:25:18,850 --> 00:25:20,231
盲錄率有多少

677
00:25:20,231 --> 00:25:23,953
然後CPU裡面其實有很多個單元

678
00:25:23,953 --> 00:25:25,573
那每一個單元他的

679
00:25:27,074 --> 00:25:27,914
cycle數是多少

680
00:25:27,914 --> 00:25:29,174
也就是說他有

681
00:25:29,174 --> 00:25:31,515
他的utilization rate是多少

682
00:25:31,515 --> 00:25:34,115
就可以知道你的GPU到底是

683
00:25:34,115 --> 00:25:35,176
真的是很忙

684
00:25:35,176 --> 00:25:37,296
所以你的frame rate才會很低呢

685
00:25:37,296 --> 00:25:38,937
還是你的GPU其實

686
00:25:38,937 --> 00:25:39,857
都沒事幹

687
00:25:39,857 --> 00:25:41,717
他一直在等CPU

688
00:25:41,717 --> 00:25:44,458
所以你的frame rate才很低

689
00:25:44,458 --> 00:25:46,459
或者說你的GPU其實

690
00:25:46,459 --> 00:25:52,800
fragment在等vertex shader

691
00:25:52,800 --> 00:25:53,020
所以

692
00:25:53,999 --> 00:25:59,282
他一直在等所以才會你的frame rate那麼低

693
00:25:59,282 --> 00:26:03,464
然後Graphic Analyzer他其實就是API的

694
00:26:03,464 --> 00:26:04,305
Treasure

695
00:26:04,305 --> 00:26:06,006
就是把你所有的API都把你抓起來

696
00:26:06,874 --> 00:26:08,074
抓起來以後呢

697
00:26:08,074 --> 00:26:09,655
你就可以replay

698
00:26:09,655 --> 00:26:11,095
然後一步一步的去執行

699
00:26:11,095 --> 00:26:12,675
看看你的問題出在哪

700
00:26:12,675 --> 00:26:15,836
那他就把你一個frame裡面所有的

701
00:26:15,836 --> 00:26:17,377
API code全部都抓起來

702
00:26:17,377 --> 00:26:18,397
就這樣而已

703
00:26:18,397 --> 00:26:19,697
然後但是

704
00:26:19,697 --> 00:26:21,037
因為這樣子你

705
00:26:21,037 --> 00:26:22,958
全部抓起來以後比較

706
00:26:22,958 --> 00:26:23,618
單純了你就可以

707
00:26:23,618 --> 00:26:26,099
可以去看看到底問題出在哪

708
00:26:26,099 --> 00:26:27,599
那他現在支援

709
00:26:27,599 --> 00:26:28,959
OpenGL跟

710
00:26:28,959 --> 00:26:30,980
嗯...跟Vulkan

711
00:26:30,980 --> 00:26:31,820
但是

712
00:26:31,820 --> 00:26:33,340
我們Vulkan才剛開始做

713
00:26:33,340 --> 00:26:33,360
那

714
00:26:36,219 --> 00:26:43,083
原來的界面也不是很適合所以我們以後其實這個這個工具應該會比較focus在OpenGL

715
00:26:43,083 --> 00:26:47,766
然後Wacom以後我們就是會轉移到我不知道大家知不知道有個叫RenderDoc

716
00:26:47,766 --> 00:26:52,449
RenderDoc的工具那我們會轉成用

717
00:26:52,449 --> 00:26:54,250
Plugin support他

718
00:26:54,250 --> 00:26:55,731
然後這個是

719
00:26:55,731 --> 00:26:57,912
Offline Shader Compiler

720
00:26:57,912 --> 00:26:59,413
就是說我們常常在寫

721
00:26:59,413 --> 00:26:59,573
調整

722
00:26:59,573 --> 00:27:04,276
Performance的時候我們最後發現到我們其實是因為我們的Shader

723
00:27:05,299 --> 00:27:06,461
寫得不夠好

724
00:27:06,461 --> 00:27:08,222
所以shader太慢

725
00:27:08,222 --> 00:27:09,404
花太多時間

726
00:27:09,404 --> 00:27:11,105
這時候你可能就要微調你的shader

727
00:27:11,105 --> 00:27:13,027
那你微調shader你一直

728
00:27:13,027 --> 00:27:15,370
微調完然後你就重新build game

729
00:27:15,370 --> 00:27:16,311
然後再去看

730
00:27:16,311 --> 00:27:17,592
再去測不是很麻煩嗎

731
00:27:17,592 --> 00:27:19,554
所以他就是這個offline compiler

732
00:27:19,554 --> 00:27:20,495
他是他

733
00:27:20,495 --> 00:27:21,776
因為其實

734
00:27:21,776 --> 00:27:23,358
在OpenGL

735
00:27:23,358 --> 00:27:24,899
在driver裡面是有個

736
00:27:24,899 --> 00:27:26,621
有一個shader compiler

737
00:27:26,621 --> 00:27:27,142
你的shader是

738
00:27:28,360 --> 00:27:30,481
明碼進去然後他把你compile出來

739
00:27:30,481 --> 00:27:32,982
那這個東西就是直接從裡面提取出來

740
00:27:32,982 --> 00:27:34,482
所以跟driver是一樣的

741
00:27:34,482 --> 00:27:36,182
那他就是會

742
00:27:36,182 --> 00:27:37,783
你可以把shader輸入

743
00:27:37,783 --> 00:27:40,004
然後你看看他的cycle數有沒有減少

744
00:27:40,004 --> 00:27:42,584
你就可以比較快速的去

745
00:27:42,584 --> 00:27:45,945
去微調你的shader的performance

746
00:27:45,945 --> 00:27:47,726
然後最後一個是我們

747
00:27:47,726 --> 00:27:48,126
這還沒出

748
00:27:48,126 --> 00:27:51,527
但是這可能是我們覺得

749
00:27:51,527 --> 00:27:52,887
最

750
00:27:52,887 --> 00:27:54,948
最特別最有

751
00:27:54,948 --> 00:27:56,428
可能你們開發者會

752
00:27:56,428 --> 00:27:57,488
最喜歡的一個工具

753
00:27:58,505 --> 00:28:03,107
那希望明年可以出第一版

754
00:28:03,107 --> 00:28:04,807
就是叫Performance Advisor

755
00:28:04,807 --> 00:28:10,169
它就是自動化的會幫你去分析

756
00:28:10,169 --> 00:28:12,589
你的瓶頸可能在哪裡

757
00:28:12,589 --> 00:28:18,791
然後它是一個Command Line的工具

758
00:28:19,761 --> 00:28:21,262
所以你可以把它整...

759
00:28:21,262 --> 00:28:23,043
我們的目標是說

760
00:28:23,043 --> 00:28:24,865
開發者可以把它整合到

761
00:28:24,865 --> 00:28:27,227
整合到你的CI system裡面

762
00:28:27,227 --> 00:28:29,789
你每一次 每一天晚上你一定

763
00:28:29,789 --> 00:28:31,230
做遊戲每天都在改嘛

764
00:28:31,230 --> 00:28:31,871
每一天晚上

765
00:28:31,871 --> 00:28:33,472
Night Build出來以後

766
00:28:33,472 --> 00:28:33,913
也會跑這個

767
00:28:33,913 --> 00:28:36,054
Performance Advisor

768
00:28:36,054 --> 00:28:38,016
然後告訴你的Performance在哪

769
00:28:38,016 --> 00:28:39,517
那你每一天晚上

770
00:28:39,517 --> 00:28:40,058
就可以看

771
00:28:40,058 --> 00:28:42,340
Night Build之後你就可以看說

772
00:28:42,340 --> 00:28:43,721
跟昨天比起來你是不是

773
00:28:45,005 --> 00:28:47,946
performance降低了,你的fps降低了

774
00:28:47,946 --> 00:28:49,087
如果降低了

775
00:28:49,087 --> 00:28:52,849
他卡在哪邊,本來可能是fragment bump

776
00:28:52,849 --> 00:28:54,990
可能shift到vertical bump

777
00:28:54,990 --> 00:28:57,871
那這個都可以讓你很快的就可以第一眼就可以看出來

778
00:28:57,871 --> 00:29:01,853
剛剛像Streamline的工具其實

779
00:29:01,853 --> 00:29:02,833
老實講

780
00:29:02,833 --> 00:29:04,094
如果沒有

781
00:29:04,094 --> 00:29:07,116
對硬體很了解的話用起來其實是

782
00:29:07,116 --> 00:29:11,438
要一段時間學習的啦,那這個工具就是希望能給開發者有一個

783
00:29:12,580 --> 00:29:13,421
更簡單的工具

784
00:29:13,421 --> 00:29:15,243
他只要run這個工具

785
00:29:15,243 --> 00:29:16,964
跑遊戲的時候run這個工具

786
00:29:16,964 --> 00:29:22,108
就可以幫你做出一份最簡單

787
00:29:22,108 --> 00:29:24,049
最開始的一個表格

788
00:29:24,049 --> 00:29:26,932
那將來當然是希望說

789
00:29:26,932 --> 00:29:33,377
他可以偵測到所有非常常見的一些瓶頸

790
00:29:33,377 --> 00:29:36,980
那其實這邊就跟大家講一下說這個

791
00:29:39,446 --> 00:29:47,409
一個遊戲的Performance的調整流程是怎麼樣

792
00:29:47,409 --> 00:29:50,850
基本上第一個就是說

793
00:29:50,850 --> 00:29:53,611
你要先找出你的問題在哪裡

794
00:29:53,611 --> 00:29:55,112
有很多時候其實

795
00:30:00,070 --> 00:30:02,191
你看frame rate很低

796
00:30:02,191 --> 00:30:03,972
但是它其實有很多原因發生

797
00:30:03,972 --> 00:30:05,913
如果你不先找出來問題的話

798
00:30:05,913 --> 00:30:09,595
其實你直接就下去做

799
00:30:09,595 --> 00:30:09,995
做

800
00:30:09,995 --> 00:30:12,117
修改程式其實是浪費時間啦

801
00:30:12,117 --> 00:30:13,938
因為你frame rate低有可能是

802
00:30:13,938 --> 00:30:15,839
CPU造成也有可能是GPU造成

803
00:30:15,839 --> 00:30:17,920
就算是GPU造成也有可能是

804
00:30:17,920 --> 00:30:20,021
Vertex造成也有可能是Fragment造成

805
00:30:20,021 --> 00:30:22,062
也有可能是Memory

806
00:30:22,062 --> 00:30:24,083
Bandwidth造成都有可能

807
00:30:24,083 --> 00:30:26,225
所以第一步其實是應該要找出一個

808
00:30:26,225 --> 00:30:26,245
一個

809
00:30:28,656 --> 00:30:29,857
一個原因

810
00:30:29,857 --> 00:30:31,197
然後再來你要

811
00:30:31,197 --> 00:30:32,718
你要再去

812
00:30:32,718 --> 00:30:33,939
去

813
00:30:33,939 --> 00:30:35,640
看它是為什麼會發生的

814
00:30:35,640 --> 00:30:37,481
然後再去想辦法解決

815
00:30:37,481 --> 00:30:38,041
然後這是一個

816
00:30:39,740 --> 00:30:41,001
一個一個循環的過程

817
00:30:41,001 --> 00:30:41,921
Iteration的過程

818
00:30:41,921 --> 00:30:43,202
你要做很多很多次

819
00:30:43,202 --> 00:30:45,964
直到你達到你要的目標以後

820
00:30:45,964 --> 00:30:50,787
然後這時候你就要轉往下一個目標去看

821
00:30:50,787 --> 00:30:53,869
第一步你要先找出最嚴重的問題

822
00:30:53,869 --> 00:30:56,610
然後一步一步的去解決

823
00:30:56,610 --> 00:30:58,492
你可能會去猜測它的原因

824
00:30:58,492 --> 00:30:59,552
然後你修正

825
00:30:59,552 --> 00:31:00,713
然後再去重測一次

826
00:31:00,713 --> 00:31:02,654
可能你猜錯了

827
00:31:02,654 --> 00:31:05,076
那你可能要再猜一次

828
00:31:05,076 --> 00:31:07,017
然後直到它這個問題解決

829
00:31:07,017 --> 00:31:08,198
那你就這時候

830
00:31:09,891 --> 00:31:11,813
第二嚴重的問題就會變第一嚴重

831
00:31:11,813 --> 00:31:14,116
那你就要再去看那個問題

832
00:31:14,116 --> 00:31:15,497
當你在做這些事情的時候

833
00:31:15,497 --> 00:31:19,021
其實你要有

834
00:31:19,021 --> 00:31:20,343
第一個要有固定的資料

835
00:31:20,343 --> 00:31:21,664
每一次的資料都要一樣

836
00:31:21,664 --> 00:31:25,268
才有辦法好好的做Performance的調整

837
00:31:25,268 --> 00:31:26,690
第二個是

838
00:31:26,690 --> 00:31:28,192
你要有一個好的工具

839
00:31:28,192 --> 00:31:28,813
去調整

840
00:31:29,695 --> 00:31:30,576
去收集資料

841
00:31:30,576 --> 00:31:32,397
所以我們的目標就是

842
00:31:32,397 --> 00:31:36,281
這個Toolset就是提供開發者一個好的工具

843
00:31:36,281 --> 00:31:39,744
可以收集到很真實而且很完整的資料

844
00:31:39,744 --> 00:31:41,866
那至於開發者他

845
00:31:41,866 --> 00:31:44,388
你們最好在做Performance調整的時候

846
00:31:44,388 --> 00:31:48,491
是能夠有一個一致的環境

847
00:31:48,491 --> 00:31:50,353
就是每一次測的東西都是一樣的

848
00:31:50,353 --> 00:31:51,674
而不是用遊戲的過程去測

849
00:31:51,674 --> 00:31:52,775
因為用遊戲的過程去測其實

850
00:31:55,495 --> 00:31:56,995
每一次都有差距

851
00:31:56,995 --> 00:31:59,976
最好是有一個測試的場景去測

852
00:31:59,976 --> 00:32:02,957
你這樣子在做Performance的調整的時候

853
00:32:02,957 --> 00:32:05,618
才會比較有效率

854
00:32:05,618 --> 00:32:09,019
然後這個就是我們這個工具的想法

855
00:32:09,019 --> 00:32:11,460
第一個呢就是

856
00:32:11,460 --> 00:32:13,561
我們那個Performance Advisor就是

857
00:32:13,561 --> 00:32:15,001
給你第一步的初步執行

858
00:32:15,001 --> 00:32:17,522
讓你知道說你到底卡在哪裡

859
00:32:17,522 --> 00:32:18,362
你的瓶頸在哪

860
00:32:18,362 --> 00:32:20,723
CPU還是GPU還是Memory

861
00:32:20,723 --> 00:32:23,044
然後呢Streamline就是讓你去分析

862
00:32:24,182 --> 00:32:27,164
分析說這個

863
00:32:27,164 --> 00:32:29,746
如果是卡在Vertex Bound

864
00:32:29,746 --> 00:32:31,688
或者是卡在Fragment

865
00:32:31,688 --> 00:32:33,169
總之卡在GPU

866
00:32:33,169 --> 00:32:34,970
它還有很多細節的原因

867
00:32:34,970 --> 00:32:36,911
你要用Streamline去找出原因

868
00:32:36,911 --> 00:32:38,753
那如果是在CPU的話呢

869
00:32:38,753 --> 00:32:41,355
你就要去最佳化你的程式碼

870
00:32:41,355 --> 00:32:44,437
但是如果它是

871
00:32:44,437 --> 00:32:45,317
卡在GPU的話

872
00:32:45,317 --> 00:32:46,598
你可能就要用這個

873
00:32:46,598 --> 00:32:49,340
我剛才講的API的Tracer

874
00:32:49,340 --> 00:32:51,442
一步一步的去檢查你的

875
00:32:51,442 --> 00:32:53,483
API看看問題出在哪

876
00:32:53,483 --> 00:32:53,623
然後

877
00:32:54,780 --> 00:32:57,480
後面的offline shader compiler的工具

878
00:32:57,480 --> 00:32:58,961
就是讓你去調整

879
00:32:58,961 --> 00:33:01,581
如果你發現你的問題是出現在shader

880
00:33:01,581 --> 00:33:04,562
你就去調整你的shader

881
00:33:04,562 --> 00:33:06,522
那Streamline這個大概的介面是這樣

882
00:33:06,522 --> 00:33:07,802
我今天不會講細節

883
00:33:07,802 --> 00:33:09,823
但是大概就是這個樣子

884
00:33:09,823 --> 00:33:11,283
那跟你們

885
00:33:11,283 --> 00:33:13,244
跟很多在那個Unity

886
00:33:13,244 --> 00:33:14,924
或者是Unreal的那個profiler

887
00:33:14,924 --> 00:33:15,704
其實是很像的

888
00:33:15,704 --> 00:33:17,204
它就是一個時間列

889
00:33:17,204 --> 00:33:20,105
然後它一直給你每一個counter的資料

890
00:33:20,105 --> 00:33:21,465
但是

891
00:33:21,465 --> 00:33:22,366
它的困難度在於

892
00:33:22,366 --> 00:33:24,026
你要知道每一個counter的

893
00:33:27,569 --> 00:33:29,089
它在哪裡發生的

894
00:33:29,089 --> 00:33:30,230
發生的原因

895
00:33:30,230 --> 00:33:31,730
還有它們相互接的關係

896
00:33:31,730 --> 00:33:34,912
你才能導出一些有用的資料來

897
00:33:34,912 --> 00:33:35,952
然後

898
00:33:35,952 --> 00:33:37,473
這邊我稍微講一下就是說

899
00:33:37,473 --> 00:33:38,373
其實基本上

900
00:33:38,373 --> 00:33:41,594
Performance的發生

901
00:33:41,594 --> 00:33:43,875
其實不外乎幾個原因

902
00:33:43,875 --> 00:33:45,256
第一個這個是

903
00:33:45,256 --> 00:33:45,456
這個叫做

904
00:33:48,405 --> 00:33:49,787
V-sync bar

905
00:33:49,787 --> 00:33:51,608
其實基本上這個就等於

906
00:33:51,608 --> 00:33:53,110
你已經達到最完美的狀態

907
00:33:53,110 --> 00:33:54,971
就是說你的GPU

908
00:33:54,971 --> 00:33:56,773
你的CPU做完了以後

909
00:33:56,773 --> 00:33:58,595
做完以後他會等

910
00:33:58,595 --> 00:34:00,056
等V-sync到了

911
00:34:00,056 --> 00:34:00,637
他就上去

912
00:34:00,637 --> 00:34:03,539
基本上你已經達到你的performance

913
00:34:03,539 --> 00:34:04,921
你要的frame rate

914
00:34:04,921 --> 00:34:07,983
所以這個基本上就是你要

915
00:34:07,983 --> 00:34:09,585
你做performance調整的時候

916
00:34:09,585 --> 00:34:12,207
要想要達到的狀態

917
00:34:12,207 --> 00:34:12,888
然後再來呢

918
00:34:12,888 --> 00:34:14,770
就是所謂的Fragment bar

919
00:34:16,148 --> 00:34:17,048
你可以看到在這裡

920
00:34:17,048 --> 00:34:19,389
Vertex

921
00:34:19,389 --> 00:34:21,489
這就是用Streamline可以看得出來的一些

922
00:34:21,489 --> 00:34:24,190
一些Performance的症狀

923
00:34:24,190 --> 00:34:26,111
就是說你可以看到Vertex

924
00:34:26,111 --> 00:34:28,051
橘色這邊 Vertex這邊

925
00:34:28,051 --> 00:34:30,132
幾乎沒什麼在做事

926
00:34:30,132 --> 00:34:32,113
但是Fragment一直在很麻

927
00:34:32,113 --> 00:34:33,873
那當你看到這種圖形的時候

928
00:34:33,873 --> 00:34:35,594
你就很快就可以知道說

929
00:34:35,594 --> 00:34:38,314
你的遊戲是卡在FragmentShader

930
00:34:38,314 --> 00:34:41,335
這時候你VertexShader其實可以再多做一點

931
00:34:41,335 --> 00:34:42,776
是不會影響到Framerate

932
00:34:42,776 --> 00:34:44,156
那如果Framerate達不到

933
00:34:44,156 --> 00:34:45,636
你要做的是減少

934
00:34:46,620 --> 00:34:48,580
Fragment的負擔 而不是說

935
00:34:48,580 --> 00:34:51,401
你看到Fragment沒達到 那我們就

936
00:34:51,401 --> 00:34:53,501
叫美術Polygon用少一點

937
00:34:53,501 --> 00:34:55,462
那時候沒有用啊 如果是FragmentShader

938
00:34:55,462 --> 00:34:58,082
你Polygon用再少也沒有用

939
00:34:58,082 --> 00:34:59,742
然後 再來就是

940
00:34:59,742 --> 00:34:59,862
這種情況

941
00:34:59,862 --> 00:35:04,463
這是CPUBomb 但是

942
00:35:04,463 --> 00:35:06,504
這個比較tricky的就是說

943
00:35:06,504 --> 00:35:07,624
你在這邊看到

944
00:35:07,624 --> 00:35:10,645
你可以看到就是說

945
00:35:10,645 --> 00:35:11,945
你的

946
00:35:11,945 --> 00:35:13,525
VertexShader跟FragmentShader

947
00:35:14,373 --> 00:35:15,313
其實都不是很忙

948
00:35:15,313 --> 00:35:16,194
他都在等

949
00:35:16,194 --> 00:35:17,655
其實他就是在等CPU

950
00:35:17,655 --> 00:35:19,035
可是你在這邊比較tricky

951
00:35:19,035 --> 00:35:21,376
就是說你看到CPU其實

952
00:35:21,376 --> 00:35:23,377
有50%BZ啊

953
00:35:23,377 --> 00:35:24,758
那是因為現在其實

954
00:35:24,758 --> 00:35:26,839
CPU

955
00:35:26,839 --> 00:35:28,800
現在的CPU都是多核的

956
00:35:28,800 --> 00:35:30,381
所以你必須要把它打開來看

957
00:35:30,381 --> 00:35:32,802
因為尤其現在因為API

958
00:35:32,802 --> 00:35:34,803
OpenGL API只有一個

959
00:35:34,803 --> 00:35:36,444
只能在single thread跑

960
00:35:36,444 --> 00:35:37,865
所以他基本上很可能是

961
00:35:38,802 --> 00:35:39,942
基本上都是會這樣啦

962
00:35:39,942 --> 00:35:42,023
在一個CPU跑到百分之百

963
00:35:42,023 --> 00:35:43,703
另外一個CPU都在idle

964
00:35:43,703 --> 00:35:45,804
所以你平均下來你看到是百分之五十

965
00:35:45,804 --> 00:35:47,344
但其實事實上

966
00:35:47,344 --> 00:35:51,986
可能有一顆GPU已經滿載了

967
00:35:51,986 --> 00:35:56,107
然後再來就是

968
00:35:56,107 --> 00:35:58,007
第三種 第四種狀況

969
00:35:58,007 --> 00:35:58,307
這個叫做

970
00:35:58,307 --> 00:36:02,989
Serialization的Problem

971
00:36:02,989 --> 00:36:03,149
就是說

972
00:36:04,145 --> 00:36:10,208
你可以看到CPU、Vertex跟Fragment這三者

973
00:36:10,208 --> 00:36:12,309
都沒有同時在執行

974
00:36:12,309 --> 00:36:13,230
都是一個等一個

975
00:36:13,230 --> 00:36:14,911
CPU做完了以後Vertex才做

976
00:36:14,911 --> 00:36:17,552
Vertex做完以後Fragment才做

977
00:36:17,552 --> 00:36:19,513
一個等一個同時都沒有在變形

978
00:36:19,513 --> 00:36:25,336
其實GPU是一個高度平行化的一個處理器

979
00:36:25,336 --> 00:36:29,859
所以說當你每一個資料都在等前一個的時候

980
00:36:29,859 --> 00:36:30,559
就會造成它

981
00:36:32,394 --> 00:36:33,895
performance不是很好

982
00:36:33,895 --> 00:36:36,478
那這種情況你就要去查一些原因

983
00:36:36,478 --> 00:36:39,682
那通常在OpenGL是比較不會發生啦

984
00:36:39,682 --> 00:36:42,305
但是如果在Vulkan的時候

985
00:36:42,305 --> 00:36:44,428
因為Vulkan 在Vulkan的時候

986
00:36:44,428 --> 00:36:48,012
所有的同步的工作要application自己去負責

987
00:36:48,012 --> 00:36:50,735
那就有可能會發生這樣的情形

988
00:36:50,735 --> 00:36:51,876
如果你的同步用的太

989
00:36:53,421 --> 00:36:54,582
太aggressive的話

990
00:36:54,582 --> 00:36:55,122
因為你怕出錯

991
00:36:55,122 --> 00:36:56,983
所以就到處都同步

992
00:36:56,983 --> 00:36:58,264
那就會一個等一個

993
00:36:58,264 --> 00:37:01,085
那這樣的也是會造成你的performance不好

994
00:37:01,085 --> 00:37:02,906
然後再來這個是比較特殊的情形

995
00:37:02,906 --> 00:37:04,987
就是

996
00:37:04,987 --> 00:37:06,828
你看你的fragment的shader

997
00:37:06,828 --> 00:37:08,109
跟vertex shader都

998
00:37:08,109 --> 00:37:09,750
你看你

999
00:37:09,750 --> 00:37:11,811
你現在是fragment的bomb

1000
00:37:11,811 --> 00:37:13,912
但是你的fragment shader都一直都很忙

1001
00:37:16,179 --> 00:37:21,545
可是你的Frame Rate 卻一直往下掉

1002
00:37:21,545 --> 00:37:25,749
那個是因為現在的Mobile都會有降頻的機制

1003
00:37:25,749 --> 00:37:30,034
當你的GPU 或者CPU到了一個溫度以後

1004
00:37:30,034 --> 00:37:31,796
它就會開始降頻 免得過熱

1005
00:37:33,295 --> 00:37:37,337
那你會 所以這時候你就要打開你的GPU的cycle數來看

1006
00:37:37,337 --> 00:37:39,859
你可以看到它的cycle數越來越降 越來越降

1007
00:37:39,859 --> 00:37:42,420
不然你就會以為它一直都是百分之百忙碌

1008
00:37:42,420 --> 00:37:45,181
但是frame rate為什麼越來越低 越來越低

1009
00:37:45,181 --> 00:37:46,642
其實它就是因為頻率一直在降

1010
00:37:48,145 --> 00:37:53,829
那大概其實Mobile上面的Performance調整的狀況大概就不出這幾種狀況

1011
00:37:53,829 --> 00:37:56,550
那用那個工具你就可以很容易的看出來

1012
00:37:56,550 --> 00:38:02,034
基本上就是CPU Vertex Fragment之間有沒有很好的平行工作

1013
00:38:02,034 --> 00:38:04,515
只要你有很好的平行工作效能就會好

1014
00:38:04,515 --> 00:38:09,278
阿如果沒有就會造成Performance的問題

1015
00:38:09,278 --> 00:38:13,280
那這個是我們的工具它可以在上面剛才是存在

1016
00:38:13,280 --> 00:38:16,522
做一些標記讓你知道說這段時間在做什麼事

1017
00:38:16,522 --> 00:38:17,323
所以造成CPU

1018
00:38:18,648 --> 00:38:19,909
GPU突然飆高

1019
00:38:19,909 --> 00:38:23,232
你可能是在做計算燈光或什麼

1020
00:38:23,232 --> 00:38:24,713
你可以自己做一些標記

1021
00:38:24,713 --> 00:38:27,796
所以還滿方便的

1022
00:38:27,796 --> 00:38:28,697
然後

1023
00:38:28,697 --> 00:38:32,820
再來這個就沒什麼

1024
00:38:32,820 --> 00:38:33,541
這個應該滿多

1025
00:38:33,541 --> 00:38:35,502
外面有滿多類似的工具

1026
00:38:35,502 --> 00:38:37,744
基本上就是

1027
00:38:37,744 --> 00:38:38,025
把API

1028
00:38:38,025 --> 00:38:40,326
Trace抓下來

1029
00:38:40,326 --> 00:38:42,648
但是有一個就是說

1030
00:38:42,648 --> 00:38:44,009
這個工具是沒辦法幫你看出

1031
00:38:44,967 --> 00:38:46,548
有很多人以為用這個工具

1032
00:38:46,548 --> 00:38:48,749
你就可以找出你的Performance的瓶頸

1033
00:38:48,749 --> 00:38:49,950
其實是沒有辦法

1034
00:38:49,950 --> 00:38:51,330
這個工具是幫你除錯而已

1035
00:38:51,330 --> 00:38:54,012
你找出瓶頸還是要用剛剛Stringline

1036
00:38:54,012 --> 00:38:55,293
就是要去做Counter

1037
00:38:55,293 --> 00:38:56,393
你先找出瓶頸以後

1038
00:38:56,393 --> 00:38:58,815
才能用這個工具去查

1039
00:38:58,815 --> 00:38:58,955
為什麼發生這個問題

1040
00:39:01,676 --> 00:39:05,399
那它大概基本上這個我想大家都用過很多次

1041
00:39:05,399 --> 00:39:07,100
很多其他的工具就很類似

1042
00:39:07,100 --> 00:39:08,861
它也沒什麼其他特別的

1043
00:39:08,861 --> 00:39:11,283
就是可以幫你的API列出來

1044
00:39:11,283 --> 00:39:14,265
幫你的用到的資源還有資料都列出來

1045
00:39:14,265 --> 00:39:15,886
讓你比較好出錯

1046
00:39:15,886 --> 00:39:19,188
那我們這個它有提供了幾個不同的view

1047
00:39:19,807 --> 00:39:20,888
Rule Mode

1048
00:39:20,888 --> 00:39:22,670
第一個就是普通的

1049
00:39:22,670 --> 00:39:24,951
第二個是所謂的X-Ray的

1050
00:39:24,951 --> 00:39:27,213
就是通常就是給你看OverDraw

1051
00:39:27,213 --> 00:39:29,815
你可以看到越白的地方

1052
00:39:29,815 --> 00:39:31,036
就是OverDraw越嚴重

1053
00:39:31,036 --> 00:39:33,658
那這樣你就不用自己去改Shader來做這事情

1054
00:39:33,658 --> 00:39:38,702
你就直接用我們的工具抓起來以後就可以看OverDraw的問題

1055
00:39:38,702 --> 00:39:40,384
然後再來第三個是

1056
00:39:40,384 --> 00:39:45,528
他會把每一個用的不同的Shader用不同的顏色來代替

1057
00:39:45,528 --> 00:39:46,869
這樣你可以看到

1058
00:39:48,940 --> 00:39:50,601
假設你現在是Fragment棒

1059
00:39:50,601 --> 00:39:52,242
那你要先找出來

1060
00:39:52,242 --> 00:39:55,563
哪一個Fragment是最Heavy的

1061
00:39:55,563 --> 00:39:57,605
那你就可以從畫面的面積去看出來

1062
00:39:57,605 --> 00:39:59,286
然後你就可以去點它

1063
00:39:59,286 --> 00:40:00,586
就可以知道它的

1064
00:40:00,586 --> 00:40:03,648
因為你的FragmentShader

1065
00:40:03,648 --> 00:40:05,309
進到Driver以後就是一串編號

1066
00:40:05,309 --> 00:40:06,370
你也不知道到底是誰

1067
00:40:06,370 --> 00:40:07,930
你就可以從這邊去找出它的編號

1068
00:40:07,930 --> 00:40:10,492
然後去看

1069
00:40:10,492 --> 00:40:11,933
然後這個Offline Compiler就

1070
00:40:13,240 --> 00:40:14,941
就很簡單 它只是一個Compile Line

1071
00:40:14,941 --> 00:40:16,563
就把你的Share的輸入

1072
00:40:16,563 --> 00:40:17,764
它會告訴你 你這個

1073
00:40:17,764 --> 00:40:21,447
A就是你的數學運算用了多少

1074
00:40:21,447 --> 00:40:24,049
你的Load跟Store用了多少個Cycle

1075
00:40:24,049 --> 00:40:26,251
然後你的Texture用了多少個Cycle

1076
00:40:26,251 --> 00:40:28,372
然後你去做

1077
00:40:28,372 --> 00:40:31,135
Fitune

1078
00:40:31,135 --> 00:40:32,155
那這邊就是說

1079
00:40:32,155 --> 00:40:33,356
你要看 譬如說

1080
00:40:33,356 --> 00:40:33,737
像第一個這個狀況

1081
00:40:33,737 --> 00:40:33,957
是 它是

1082
00:40:38,299 --> 00:40:40,120
放在數學運算

1083
00:40:40,120 --> 00:40:43,102
這時候你如果發現你是放在數學運算

1084
00:40:43,102 --> 00:40:44,423
你去調整texture

1085
00:40:44,423 --> 00:40:45,923
去調整log跟store

1086
00:40:45,923 --> 00:40:47,985
其實都是沒有用的

1087
00:40:47,985 --> 00:40:50,826
因為基本上他都是在等數學運算

1088
00:40:50,826 --> 00:40:53,388
所以這時候如果你看到你的shader是這樣

1089
00:40:53,388 --> 00:40:54,889
你就要去調整你的數學運算

1090
00:40:54,889 --> 00:40:56,069
減少你的數學運算

1091
00:40:56,069 --> 00:40:59,891
你才會cycle數才會減少

1092
00:40:59,891 --> 00:41:02,753
然後再來就是最後這個performance advisor

1093
00:41:02,753 --> 00:41:07,636
那這是我們一般的分析的流程

1094
00:41:08,556 --> 00:41:10,237
基本上就是

1095
00:41:10,237 --> 00:41:11,058
先量

1096
00:41:11,058 --> 00:41:13,039
就是看你的Frame Rate如果太低的話

1097
00:41:13,039 --> 00:41:15,281
你就要找出你的可能的問題

1098
00:41:15,281 --> 00:41:15,981
然後呢

1099
00:41:15,981 --> 00:41:17,382
你要人工的去做分析

1100
00:41:17,382 --> 00:41:19,444
就剛剛用Spline去做分析

1101
00:41:19,444 --> 00:41:24,368
然後分析出可能的原因以後

1102
00:41:24,368 --> 00:41:26,789
分析出造成的原因以後

1103
00:41:26,789 --> 00:41:27,850
你再去請說

1104
00:41:27,850 --> 00:41:29,831
比如說是請Art去修改呢

1105
00:41:29,831 --> 00:41:30,972
還是請誰去修改

1106
00:41:30,972 --> 00:41:32,293
還是請Engine去修改

1107
00:41:32,293 --> 00:41:33,714
還是Gameplay去修改

1108
00:41:33,714 --> 00:41:35,175
那這樣子就是很靠人工

1109
00:41:35,175 --> 00:41:37,237
所以你一定要是

1110
00:41:39,512 --> 00:41:40,853
每次都要找的工程師

1111
00:41:40,853 --> 00:41:43,775
每次要調performance都要找

1112
00:41:43,775 --> 00:41:46,036
有受過訓練的工程師才能夠來做

1113
00:41:46,036 --> 00:41:48,998
那這樣子不是每一個公司都負擔得起

1114
00:41:48,998 --> 00:41:49,818
那所以

1115
00:41:49,818 --> 00:41:52,160
但其實這個分析這個的工作呢

1116
00:41:52,160 --> 00:41:54,922
其實有很多

1117
00:41:54,922 --> 00:41:59,905
很普通的問題其實是很容易用電腦去

1118
00:41:59,905 --> 00:42:00,806
去預測出來

1119
00:42:00,806 --> 00:42:02,006
去看得出來的

1120
00:42:02,006 --> 00:42:03,607
所以我們這個工具呢就是要把這邊

1121
00:42:06,154 --> 00:42:07,954
就是取代掉剛剛人工

1122
00:42:07,954 --> 00:42:09,494
剛剛可以看到人工這部分

1123
00:42:09,494 --> 00:42:11,395
直接用電腦

1124
00:42:11,395 --> 00:42:14,095
就可以幫你

1125
00:42:14,095 --> 00:42:16,496
偵測出一些簡單的問題的原因

1126
00:42:16,496 --> 00:42:18,176
然後就可以直接

1127
00:42:18,176 --> 00:42:21,236
如果是ART的問題就直接請ART趕快改

1128
00:42:21,236 --> 00:42:22,537
那如果是GAMEPLAY的

1129
00:42:22,537 --> 00:42:23,997
或者是ENGINE的問題

1130
00:42:23,997 --> 00:42:27,378
那真正困難的問題呢

1131
00:42:27,378 --> 00:42:30,538
才留給人工去解決

1132
00:42:30,538 --> 00:42:32,739
那他大概會給你一個這樣的介面

1133
00:42:32,739 --> 00:42:33,359
他會告訴你說你

1134
00:42:35,229 --> 00:42:40,551
後面這邊會看到你的Performance

1135
00:42:40,551 --> 00:42:40,571
現在

1136
00:42:40,571 --> 00:42:43,332
你的CPU的負擔佔了多少

1137
00:42:43,332 --> 00:42:47,053
你的Vertex、Fragment的負擔各佔多少

1138
00:42:47,053 --> 00:42:48,154
然後Frame Rate是多少

1139
00:42:48,154 --> 00:42:49,054
它會幫你分析出來

1140
00:42:49,054 --> 00:42:52,175
然後它也可以給你一個像這樣的圖表

1141
00:42:52,175 --> 00:42:53,075
在每一個時段

1142
00:42:53,075 --> 00:42:55,576
那你可以看到上面那些時

1143
00:42:55,576 --> 00:42:56,576
在做什麼事情呢

1144
00:42:56,576 --> 00:42:58,517
是Application

1145
00:42:59,307 --> 00:43:01,989
application可以去指定

1146
00:43:01,989 --> 00:43:03,250
去在裡面做mark

1147
00:43:03,250 --> 00:43:03,950
然後你就可以看得出來說

1148
00:43:03,950 --> 00:43:06,112
現在是做vertical line的時候

1149
00:43:06,112 --> 00:43:09,214
它是卡在vertex shader

1150
00:43:09,214 --> 00:43:10,976
然後做什麼的時候是卡在哪裡

1151
00:43:10,976 --> 00:43:11,956
或者是卡在memory

1152
00:43:11,956 --> 00:43:15,619
它都會可以做一個圖表給你

1153
00:43:15,619 --> 00:43:16,019
然後呢

1154
00:43:16,019 --> 00:43:18,041
每一個區域它也可以出一張這樣的

1155
00:43:19,560 --> 00:43:20,601
這樣的報告給你

1156
00:43:20,601 --> 00:43:23,782
就是你剛剛有標出來說這個是loading

1157
00:43:23,782 --> 00:43:24,982
這個是做vertical lighting

1158
00:43:24,982 --> 00:43:26,563
這是render shadow

1159
00:43:26,563 --> 00:43:27,803
然後這個是render scene

1160
00:43:27,803 --> 00:43:29,864
他每一個這一個區段

1161
00:43:29,864 --> 00:43:32,665
他都可以做一個這樣的標給你

1162
00:43:32,665 --> 00:43:33,785
那

1163
00:43:33,785 --> 00:43:34,746
現在我們還在

1164
00:43:34,746 --> 00:43:37,787
除了剛剛這個advisor工具

1165
00:43:37,787 --> 00:43:40,648
我們還在做一個就是friend advisor

1166
00:43:42,274 --> 00:43:44,316
就是做Friend Analyzer

1167
00:43:44,316 --> 00:43:48,000
就是這個Friend他也可以自己幫你做分析

1168
00:43:48,000 --> 00:43:49,342
而不用在人工去分析

1169
00:43:49,342 --> 00:43:53,847
那只有到最後最困難的問題才交給人工去做

1170
00:43:53,847 --> 00:43:58,051
那這樣就可以節省掉蠻多的資源

1171
00:43:59,905 --> 00:44:01,986
那這個大概是我們

1172
00:44:01,986 --> 00:44:03,327
這因為我們才剛出來

1173
00:44:03,327 --> 00:44:04,407
可能很多人都不知道

1174
00:44:04,407 --> 00:44:05,528
我是覺得

1175
00:44:05,528 --> 00:44:06,788
如果你們在做手機遊戲

1176
00:44:06,788 --> 00:44:08,449
其實是可以下載來試試看的

1177
00:44:08,449 --> 00:44:10,910
如果你們有在調performance的話

1178
00:44:10,910 --> 00:44:12,972
可以下載來看看

1179
00:44:12,972 --> 00:44:15,433
其實是

1180
00:44:15,433 --> 00:44:17,274
蠻好用的啦

1181
00:44:17,274 --> 00:44:18,935
因為其實像Unity的話

1182
00:44:18,935 --> 00:44:19,835
它的profile

1183
00:44:19,835 --> 00:44:22,176
它只能告訴你很在

1184
00:44:24,337 --> 00:44:27,439
大概到API level的資訊而已

1185
00:44:27,439 --> 00:44:31,062
但是再往下的話你就真的要要一些比較

1186
00:44:31,062 --> 00:44:33,564
硬體廠出的工具才有辦法去調整

1187
00:44:33,564 --> 00:44:34,985
才看得出來

1188
00:44:34,985 --> 00:44:38,208
然後呢這個是我的email

1189
00:44:38,208 --> 00:44:39,930
這是公司的自飾的

1190
00:44:39,930 --> 00:44:43,292
這是我的email那你們有任何

1191
00:44:43,292 --> 00:44:44,573
因為我的我的

1192
00:44:44,573 --> 00:44:47,356
主要的工作就是協助開發者嘛所以你們有任何

1193
00:44:49,095 --> 00:44:50,316
技術上的問題

1194
00:44:50,316 --> 00:44:50,636
通常是

1195
00:44:50,636 --> 00:44:52,037
應該是GPU啦

1196
00:44:52,037 --> 00:44:53,718
如果CPU有的話你也可以

1197
00:44:53,718 --> 00:44:55,359
跟我講我可以幫你找

1198
00:44:55,359 --> 00:44:57,780
找對的人去

1199
00:44:57,780 --> 00:44:59,041
去幫你解決

1200
00:44:59,041 --> 00:45:01,062
有任何開發上的問題呢

1201
00:45:01,062 --> 00:45:03,643
就可以寄這email給我

1202
00:45:03,643 --> 00:45:05,624
我都可以幫你們解

1203
00:45:05,624 --> 00:45:06,385
幫你們看看啦

1204
00:45:06,385 --> 00:45:07,545
不一定能解決的了

1205
00:45:07,545 --> 00:45:10,207
但是我可以丟到

1206
00:45:10,207 --> 00:45:11,187
適合的人那邊去解決

1207
00:45:11,187 --> 00:45:12,228
因為有時候如果是driver

1208
00:45:12,228 --> 00:45:13,409
driver我也解決不了

1209
00:45:13,409 --> 00:45:16,870
那就要driver team的人去看對

1210
00:45:16,870 --> 00:45:18,591
那你們如果遊戲要出之前

1211
00:45:19,949 --> 00:45:22,971
想要叫 請我們先測測看Performance

1212
00:45:22,971 --> 00:45:23,891
或者是相容性

1213
00:45:23,891 --> 00:45:27,153
或者是你們就可以聯絡我

1214
00:45:27,153 --> 00:45:30,534
我可以幫你們安排看看

1215
00:45:30,534 --> 00:45:32,515
好 那

1216
00:45:32,515 --> 00:45:34,296
有沒有什麼問題

1217
00:45:34,296 --> 00:45:35,036
我們先掌聲鼓勵

1218
00:45:35,036 --> 00:45:37,257
內容很多喔

1219
00:45:41,458 --> 00:45:43,139
所以我也很好奇像

1220
00:45:43,139 --> 00:45:44,539
因為一般在寫遊戲的時候

1221
00:45:44,539 --> 00:45:46,360
你有時候自己可能還是會卡到

1222
00:45:46,360 --> 00:45:48,141
跟Rendering無關的Performance

1223
00:45:48,141 --> 00:45:50,561
譬如說假設是GC卡住之類的

1224
00:45:50,561 --> 00:45:51,842
那像這樣子的

1225
00:45:51,842 --> 00:45:55,543
就是非跟Rendering有關的BioNec

1226
00:45:55,543 --> 00:45:58,884
在你的Performance Advisor裡面

1227
00:45:58,884 --> 00:46:00,404
會顯示出來像什麼樣

1228
00:46:00,404 --> 00:46:02,165
它會顯示說這是CPUBOM

1229
00:46:02,165 --> 00:46:04,106
它就把它當成完全就是CPUBOM嗎

1230
00:46:04,106 --> 00:46:05,766
還是說它會寫在Unknown之類的

1231
00:46:05,766 --> 00:46:07,687
你從那個圖你只能看得到CPUBOM

1232
00:46:07,687 --> 00:46:09,027
那你就去從

1233
00:46:09,027 --> 00:46:10,288
你就可以看得出來CPUBOM

1234
00:46:10,288 --> 00:46:10,748
那時候你就

1235
00:46:11,596 --> 00:46:14,497
不要浪費時間去看你的GPU Rendering的部分

1236
00:46:14,497 --> 00:46:16,598
然後CPU那你就要

1237
00:46:16,598 --> 00:46:18,799
就是那時候的那個叫什麼

1238
00:46:18,799 --> 00:46:21,100
Unity的Profiler就派上用處

1239
00:46:21,100 --> 00:46:22,041
就很好用了 對

1240
00:46:22,041 --> 00:46:27,803
所以其實你要從GPU跟整個你自己Gameplay的Application層都要去檢查的話

1241
00:46:27,803 --> 00:46:30,525
那就是其實不同套的工具你都要用嘛

1242
00:46:30,525 --> 00:46:31,505
就不只是這一套

1243
00:46:31,505 --> 00:46:33,586
就是這套沒有吃全部這樣子

1244
00:46:33,586 --> 00:46:34,807
對啊對啊對啊

1245
00:46:34,807 --> 00:46:35,707
他其實有啦 他有

1246
00:46:37,692 --> 00:46:40,714
如果是Android的話

1247
00:46:40,714 --> 00:46:42,015
如果你有Symbol file

1248
00:46:42,015 --> 00:46:43,516
他可以看到你的

1249
00:46:43,516 --> 00:46:45,116
哪一個Library花了多少時間

1250
00:46:45,116 --> 00:46:46,997
哪一個Function code花了多少時間

1251
00:46:46,997 --> 00:46:50,179
但是我就用Unity的profile比較清楚

1252
00:46:50,179 --> 00:46:50,499
對啊

1253
00:46:50,499 --> 00:46:53,521
有沒有其他人有問題

1254
00:46:53,521 --> 00:46:55,862
有嗎

1255
00:46:55,862 --> 00:46:58,044
還是現在趕快有

1256
00:46:58,044 --> 00:47:00,085
現場就有遊戲需要

1257
00:47:00,085 --> 00:47:01,125
提出來給

1258
00:47:01,125 --> 00:47:02,906
歐文大大檢查

1259
00:47:03,935 --> 00:47:07,117
你們有什麼樣的都可以提供給我

1260
00:47:07,117 --> 00:47:11,821
那如果你們有對我們剛才講的深度合作有興趣的話

1261
00:47:11,821 --> 00:47:13,342
就歡迎來找我

1262
00:47:13,342 --> 00:47:14,723
我可以

1263
00:47:14,723 --> 00:47:16,325
就是

1264
00:47:16,325 --> 00:47:16,885
怎麼樣

1265
00:47:16,885 --> 00:47:17,125
這叫什麼

1266
00:47:17,125 --> 00:47:19,207
Personal的

1267
00:47:19,207 --> 00:47:20,648
Approviser

1268
00:47:20,648 --> 00:47:21,188
幫你們做

1269
00:47:21,188 --> 00:47:23,390
然後

1270
00:47:23,390 --> 00:47:27,593
然後看看有沒有機會在GD上可以幫你們promote這個遊戲對

1271
00:47:27,593 --> 00:47:27,613
好

1272
00:47:33,892 --> 00:47:34,032
現場有問題嗎

1273
00:47:34,032 --> 00:47:37,656
你們可以把email寄下來

1274
00:47:37,656 --> 00:47:40,639
以後有問題就寄email給我

1275
00:47:40,639 --> 00:47:41,019
這比較重要

1276
00:47:41,019 --> 00:47:45,184
email趕快先抄下來

1277
00:47:45,184 --> 00:47:48,587
好那我們今天的分享就大概先到這樣

1278
00:47:48,587 --> 00:47:50,249
好那就是還是很感謝各位

1279
00:47:50,249 --> 00:47:51,470
這次來我們這個新場地

1280
00:47:51,470 --> 00:47:54,874
第一次參與我們今年9月份的

1281
00:47:54,874 --> 00:47:55,594
IGD share 分享會

1282
00:47:56,638 --> 00:47:58,240
好那剩下我們還是有一些時間喔

1283
00:47:58,240 --> 00:47:59,561
大家如果有還有人有需要

1284
00:47:59,561 --> 00:48:02,644
譬如說你想要現場來秀一下

1285
00:48:02,644 --> 00:48:03,385
你的遊戲

1286
00:48:03,385 --> 00:48:06,749
還是說你要跟大家就是在這邊

1287
00:48:06,749 --> 00:48:07,690
留下來時間繼續交流

1288
00:48:07,690 --> 00:48:09,091
我們這邊都繼續開放喔

1289
00:48:09,091 --> 00:48:13,396
開放大概到五點半左右

1290
00:48:13,396 --> 00:48:14,457
好那感謝

