1
00:00:00,605 --> 00:00:08,370
好 那今天我們本來就是在上半場這邊要講的是

2
00:00:08,370 --> 00:00:13,653
就是我大概一兩個月前看到就是John Blow他幾年前的影片

3
00:00:13,653 --> 00:00:15,494
然後突然間發現就是有一些細節

4
00:00:15,494 --> 00:00:18,356
其實以前自己不太了解

5
00:00:18,356 --> 00:00:20,157
然後整理一下他的心得之後

6
00:00:20,157 --> 00:00:22,138
我就覺得說好像可以自己寫一個程式

7
00:00:22,138 --> 00:00:23,599
自己來測看看

8
00:00:23,599 --> 00:00:24,600
那要測什麼東西呢

9
00:00:24,600 --> 00:00:27,061
其實主要是在測就是

10
00:00:27,061 --> 00:00:29,803
到底你的遊戲的主軌圈要怎樣做到

11
00:00:30,683 --> 00:00:36,969
就是你的gameplay可以不被frame rate影響

12
00:00:36,969 --> 00:00:38,830
這邊應該其實蠻多人都是

13
00:00:38,830 --> 00:00:40,111
已經實際自己有開發遊戲的經驗

14
00:00:40,111 --> 00:00:42,854
我覺得就不用講得太清楚

15
00:00:42,854 --> 00:00:45,316
就是大家應該都知道我在講什麼

16
00:00:45,316 --> 00:00:48,119
那如果你把遊戲的主線

17
00:00:48,119 --> 00:00:50,441
回到最傳統的C的概念來看的話

18
00:00:50,441 --> 00:00:53,103
可能他就是一個無線迴圈

19
00:00:53,103 --> 00:00:55,385
然後裡面放你要一直跑的東西

20
00:00:55,385 --> 00:00:56,406
然後你的畫面會一直更新這樣

21
00:00:57,261 --> 00:00:59,644
那有兩個東西很明顯對不起來

22
00:00:59,644 --> 00:01:03,668
一開始是一部分是你的組合圈其實它會一直跑

23
00:01:03,668 --> 00:01:06,911
然後另外一方面是你的畫面更新是有它自己的更新頻率

24
00:01:06,911 --> 00:01:09,454
所以這兩個東西是對不起來的

25
00:01:09,454 --> 00:01:14,720
那但是今天要講的東西跟像Vsync其實關聯不是很大

26
00:01:14,720 --> 00:01:16,442
但是也會有影響就是了

27
00:01:16,442 --> 00:01:18,444
好那在組合圈一開始的時候

28
00:01:21,492 --> 00:01:24,434
如果有人完全沒有寫過C 都是直接從Unity開始的話

29
00:01:24,434 --> 00:01:26,995
我這邊可能還是稍微帶一下

30
00:01:26,995 --> 00:01:28,335
譬如說一開始在組合圈的時候

31
00:01:28,335 --> 00:01:33,257
我們可能一開始會先讓玩家可以從鍵盤或是滑鼠輸入東西

32
00:01:33,257 --> 00:01:38,379
那我們就假裝有一個可以輸入東西的函數

33
00:01:38,379 --> 00:01:40,380
那可能就是input處理的就是這樣

34
00:01:40,380 --> 00:01:41,801
就是一個input

35
00:01:41,801 --> 00:01:43,922
那你輸入進來之後

36
00:01:43,922 --> 00:01:46,203
你的遊戲可能裡面有一些角色他要移動

37
00:01:46,203 --> 00:01:48,144
還是子彈要移動之類的

38
00:01:48,144 --> 00:01:49,844
然後邏輯判斷

39
00:01:49,844 --> 00:01:50,204
那這個就很簡單

40
00:01:51,367 --> 00:01:58,491
那這update的function當然在一般的遊戲引擎裡面都幫你包好了

41
00:01:58,491 --> 00:02:05,034
所以譬如說你如果是用Unity或是其他以前可能開發過Flash相關的框架的話

42
00:02:05,034 --> 00:02:08,896
你可能會直接填一個主要的class

43
00:02:08,896 --> 00:02:12,458
還是說一個它直接提供給你的update function

44
00:02:12,458 --> 00:02:18,161
然後那update function你就把你要每一個frame跟新的遊戲邏輯就放裡面

45
00:02:21,665 --> 00:02:28,108
當然更新完之後你還要想辦法把它畫到畫面上來

46
00:02:28,108 --> 00:02:32,489
那這邊可能就跟你用什麼引擎、用什麼API有關係

47
00:02:32,489 --> 00:02:35,370
但總之我們就先假裝有一個Render Function

48
00:02:35,370 --> 00:02:38,991
然後它裡面就是負責把你現在畫面上所有邏輯的東西

49
00:02:38,991 --> 00:02:44,053
就是哪裡要畫Sprite、哪裡要畫貼圖、哪裡要畫3D模型之類的

50
00:02:44,053 --> 00:02:47,794
就幫你把它貼到你的電腦的畫面上

51
00:02:47,794 --> 00:02:50,775
那基本上遊戲的組合圈核心概念就是這樣子

52
00:02:54,041 --> 00:02:59,443
但是這樣看完之後你就會發現會有一個蠻明顯的問題

53
00:02:59,443 --> 00:03:03,205
就是到底這個迴圈跑多久

54
00:03:03,205 --> 00:03:06,066
然後它怎麼跟畫面同步更新

55
00:03:06,066 --> 00:03:08,528
就是你怎麼確保這個東西它是

56
00:03:08,528 --> 00:03:10,248
譬如說我們要鎖定60fps的話

57
00:03:10,248 --> 00:03:14,770
我要怎麼樣保證它是1 1⁄60秒跑一次

58
00:03:14,770 --> 00:03:16,631
那當然現在可能很簡單就是有

59
00:03:20,158 --> 00:03:22,100
有人知道怎麼設定 Vsync 的話

60
00:03:22,100 --> 00:03:26,483
那你設好 Vsync 其實就有 OS 的底層

61
00:03:26,483 --> 00:03:28,845
或是說繪圖 API 的底層幫你直接做掉

62
00:03:28,845 --> 00:03:34,248
就是你的組合圈會直接在

63
00:03:34,248 --> 00:03:36,250
就是它會直接幫你去等那個畫面更新

64
00:03:36,250 --> 00:03:41,293
那剛好你的遊戲就會自動被壓到 60fps

65
00:03:41,293 --> 00:03:46,217
或是說被壓到剛好符合你螢幕更新頻率的每秒更新次數

66
00:03:49,211 --> 00:03:52,573
假設沒有這個限制的話

67
00:03:52,573 --> 00:03:55,395
那其實你FlyOE就是無線迴圈

68
00:03:55,395 --> 00:03:56,376
它就是無線跑

69
00:03:56,376 --> 00:04:00,159
那基本上就是

70
00:04:00,159 --> 00:04:01,660
這迴圈整個跑完可能

71
00:04:01,660 --> 00:04:03,142
如果你遊戲是很少東西的話

72
00:04:03,142 --> 00:04:05,523
可能它跑完只需要1ms、2ms

73
00:04:05,523 --> 00:04:09,527
那其實你應該可以獲得幾百甚至上千的FPS

74
00:04:15,306 --> 00:04:16,987
在接下來的一個問題是

75
00:04:16,987 --> 00:04:19,569
你 update 裡面的東西要怎麼寫

76
00:04:19,569 --> 00:04:21,230
譬如說它移動的速度

77
00:04:21,230 --> 00:04:23,451
或是它移動的那個動

78
00:04:23,451 --> 00:04:25,733
就是移動的量

79
00:04:25,733 --> 00:04:26,473
那譬如說

80
00:04:26,473 --> 00:04:30,956
假設我這邊下面有一個 update

81
00:04:30,956 --> 00:04:34,018
然後譬如說裡面有一個

82
00:04:34,018 --> 00:04:34,959
呃就

83
00:04:34,959 --> 00:04:37,281
player

84
00:04:37,281 --> 00:04:38,341
然後它

85
00:04:38,341 --> 00:04:40,443
我希望它在 update 的時候

86
00:04:40,443 --> 00:04:41,343
每次都會加移

87
00:04:43,315 --> 00:04:48,199
可是你如果用這個邏輯去寫的話,你就會發現

88
00:04:48,199 --> 00:04:53,102
我外面的組回圈每跑一次,我的PlayerX就會加1

89
00:04:53,102 --> 00:04:56,825
那剛剛講到我們這樣在跑的時候,也許我的while是很快的

90
00:04:56,825 --> 00:05:00,027
我可能是1ms就跑一輪

91
00:05:00,027 --> 00:05:07,612
那這樣就變成我的PlayerX的x座標,其實就變成是它每1ms就會加1

92
00:05:07,612 --> 00:05:11,415
然後你就會發現你的程式一執行,你的玩家就直接衝到畫面外去

93
00:05:12,732 --> 00:05:14,252
那大家如果有印象的話

94
00:05:14,252 --> 00:05:15,452
很久以前的 DOS 遊戲

95
00:05:15,452 --> 00:05:17,413
其實有些你就會發現

96
00:05:17,413 --> 00:05:19,894
就是它是故意用這種方式去鎖

97
00:05:19,894 --> 00:05:21,614
要鎖某一個特定的頻率

98
00:05:21,614 --> 00:05:23,835
才能讓遊戲玩到正常的速度

99
00:05:23,835 --> 00:05:25,815
那如果你用比較後來的

100
00:05:25,815 --> 00:05:27,236
比較新的電腦

101
00:05:27,236 --> 00:05:29,437
去玩那種很舊的 DOS 遊戲的話

102
00:05:29,437 --> 00:05:31,297
那它

103
00:05:31,297 --> 00:05:32,998
就是你還要先想辦法弄降頻

104
00:05:32,998 --> 00:05:34,898
或是用什麼特定的模擬方式

105
00:05:34,898 --> 00:05:36,239
才能去做到說

106
00:05:36,239 --> 00:05:39,700
讓那遊戲是用原本那個速度在遊玩的

107
00:05:40,865 --> 00:05:53,276
所以這個就很明顯是你的遊玩的 Gameplay 邏輯狀態並沒有跟你的 Frame Rate 脫鉤

108
00:05:53,276 --> 00:05:55,198
那當然到這邊為止大家應該都覺得就很簡單

109
00:05:55,198 --> 00:05:56,259
這邊是非常基本的東西

110
00:05:56,259 --> 00:05:59,942
就是如果我要做的話

111
00:05:59,942 --> 00:06:03,165
就是以後我可能會在

112
00:06:03,165 --> 00:06:06,648
譬如我在這邊有一個 Delta Time

113
00:06:06,648 --> 00:06:06,808
然後

114
00:06:15,723 --> 00:06:23,369
就這樣,然後我裡面的可能就是變成我不是加1,我可能是加1乘上

115
00:06:23,369 --> 00:06:26,592
譬如說delta time,然後再乘上一個常數

116
00:06:26,592 --> 00:06:31,376
反正就是你要自己去推導你的單位要怎麼設

117
00:06:31,376 --> 00:06:39,282
那總之如果你這樣設好之後,基本上你的遊戲就已經有最基礎的

118
00:06:39,282 --> 00:06:41,184
跟

119
00:06:41,184 --> 00:06:43,946
Framerate脫鉤的邏輯了

120
00:06:43,946 --> 00:06:44,087
但是

121
00:06:45,092 --> 00:06:47,193
以前我自己也是只認識到這邊而已

122
00:06:47,193 --> 00:06:50,734
但是後來才發現其實還有很多細節是

123
00:06:50,734 --> 00:06:52,435
以前可能自己沒有注意過

124
00:06:52,435 --> 00:06:55,197
也很少看到有人拿出來討論的

125
00:06:55,197 --> 00:06:56,978
所以這次就是特別想要講

126
00:06:56,978 --> 00:06:58,979
到底到這一步之後可能還會出哪些問題

127
00:06:58,979 --> 00:07:02,320
我為了要先確保說

128
00:07:05,119 --> 00:07:19,196
我不能用一套就是可能像Unity或是人家已經包裝好了整套引擎,然後再來測這個東西,因為其實這樣可能就測不準,因為它可能有些引擎底層幫你做掉一些東西,或是你要做一些很底層的操作。

129
00:07:20,543 --> 00:07:25,345
然後你還要去想辦法了解說到底那個引擎底層是怎麼執行的

130
00:07:25,345 --> 00:07:27,467
譬如說Unity裡面的update完之後

131
00:07:27,467 --> 00:07:29,748
它到render中間經過多少事情

132
00:07:29,748 --> 00:07:32,389
其實我們自己是不太清楚的

133
00:07:32,389 --> 00:07:35,871
所以我這邊就是用很傳統的CE的library

134
00:07:35,871 --> 00:07:38,893
就是一個叫SDL的的函式庫

135
00:07:38,893 --> 00:07:49,699
然後它就是很接近硬體跟OS API的包裝這樣子

136
00:07:49,699 --> 00:07:49,719
那

137
00:07:50,718 --> 00:07:54,280
我是直接從這個網站

138
00:07:54,280 --> 00:07:57,222
反正就是這個網站有人寫滿新的SDL教學

139
00:07:57,222 --> 00:07:58,502
我就把它抓下來改

140
00:07:58,502 --> 00:08:02,765
然後它是一個很簡單的射擊遊戲的模型

141
00:08:02,765 --> 00:08:06,086
那我就把它改成我想要來測的一些

142
00:08:06,086 --> 00:08:10,589
就是我把它改成我想要來測的一些東西這樣

143
00:08:10,589 --> 00:08:12,049
好

144
00:08:12,049 --> 00:08:14,651
那一開始的時候我先講一下就是

145
00:08:16,868 --> 00:08:20,371
我等一下會秀出來的畫面都只有640x360

146
00:08:20,371 --> 00:08:23,232
然後我會開...就是我會...

147
00:08:23,232 --> 00:08:24,273
執行之後會打成全螢幕

148
00:08:24,273 --> 00:08:26,894
就是...

149
00:08:26,894 --> 00:08:30,096
執行之後...

150
00:08:30,096 --> 00:08:31,957
就是會切成全螢幕

151
00:08:31,957 --> 00:08:35,199
所以這個畫面上它其實只有640x360的大小

152
00:08:35,199 --> 00:08:37,601
然後...

153
00:08:37,601 --> 00:08:39,942
它畫面是被...就是故意放大的

154
00:08:39,942 --> 00:08:41,903
然後你可以看到我的NVIDIA有啟動

155
00:08:41,903 --> 00:08:43,484
所以其實這個是硬體模擬的狀態

156
00:08:45,409 --> 00:08:49,751
就是硬體繪圖的狀態

157
00:08:49,751 --> 00:08:53,594
好那大概我今天就是我在準備這個東西的時候

158
00:08:53,594 --> 00:08:54,874
大概測了幾個東西

159
00:08:54,874 --> 00:08:58,056
然後這邊用不同的define把它設定起來

160
00:08:58,056 --> 00:08:59,877
那等下方便比較容易方便切換

161
00:08:59,877 --> 00:09:05,160
那總之一開始的時候先講就是

162
00:09:05,160 --> 00:09:06,961
我們等一下要說的東西跟Vsync

163
00:09:06,961 --> 00:09:08,762
基本上沒有什麼太直接的關聯

164
00:09:08,762 --> 00:09:11,663
那我們要看Vsync的效益

165
00:09:11,663 --> 00:09:13,084
我們可以先看沒有Vsync的時候是什麼狀態

166
00:09:15,192 --> 00:09:18,333
V-sync是防止畫面撕裂

167
00:09:18,333 --> 00:09:21,335
但是我發現畫面撕裂這個東西

168
00:09:21,335 --> 00:09:22,416
你在自己電腦上看

169
00:09:22,416 --> 00:09:23,736
跟你投影出來看的時候

170
00:09:23,736 --> 00:09:25,717
其實效果就已經不一樣了

171
00:09:25,717 --> 00:09:27,698
所以也是不太準

172
00:09:27,698 --> 00:09:29,799
如果你直接用投影機的畫面看的話

173
00:09:29,799 --> 00:09:30,800
你應該是看不到撕裂

174
00:09:30,800 --> 00:09:32,381
它會用其他的方式卡頓

175
00:09:32,381 --> 00:09:33,662
但是不會是撕裂的狀態

176
00:09:33,662 --> 00:09:38,004
那我就試一下

177
00:09:39,920 --> 00:09:43,482
這個飛機飛了之後還可以射子彈

178
00:09:43,482 --> 00:09:50,186
但你可以發現到它的子彈基本上是非常的一致 很整齊

179
00:09:50,186 --> 00:09:51,747
然後這邊也再補充一下

180
00:09:51,747 --> 00:09:55,829
因為我這邊是用最基本的SDL的函式庫

181
00:09:55,829 --> 00:09:57,910
它沒有做任何反句詞

182
00:09:57,910 --> 00:10:01,192
然後你也沒有辦法指定subpixel的位移

183
00:10:01,192 --> 00:10:03,834
所以所有的pixel它都必須要加1加1加1

184
00:10:03,834 --> 00:10:05,014
就它不能加0.5這樣

185
00:10:05,014 --> 00:10:06,975
加0.5會直接被失守不入

186
00:10:10,697 --> 00:10:13,940
所以這邊的動態就全部都是整數的

187
00:10:13,940 --> 00:10:19,084
所以你才可以看得出來為什麼動態這麼整齊

188
00:10:19,084 --> 00:10:22,287
但是你可以看到有時候畫面會跳一下跳一下

189
00:10:22,287 --> 00:10:24,829
那這個在我沒有接投影機的狀態下的時候

190
00:10:24,829 --> 00:10:29,213
就會變成是在我的電腦上會看到失列的情況

191
00:10:29,213 --> 00:10:35,559
總之這個是在投影機上沒有開V-Sync的時候的狀態

192
00:10:35,559 --> 00:10:38,021
那我們可以把V-Sync開起來

193
00:10:45,580 --> 00:10:54,507
基本上不會卡,就是順的。

194
00:10:54,507 --> 00:11:00,692
所以我要強調就是說,現在已經是有Vsync,有double buffer的狀態,

195
00:11:00,692 --> 00:11:06,697
所以我等一下要講的東西跟Vsync基本上是完全沒有什麼關聯的。

196
00:11:06,697 --> 00:11:10,900
剛剛有提到說我們最基本要做的事情就是,

197
00:11:10,900 --> 00:11:11,360
我們要先確認

198
00:11:12,844 --> 00:11:14,445
要把delta time的功能加進去

199
00:11:14,445 --> 00:11:17,368
那如果不加的話會怎樣

200
00:11:17,368 --> 00:11:20,770
那我們就可以先模擬一下

201
00:11:20,770 --> 00:11:24,993
譬如說我剛剛是設定每16點多秒

202
00:11:24,993 --> 00:11:27,295
這邊是一個範例程式裡面

203
00:11:27,295 --> 00:11:29,797
它原本留的就是

204
00:11:29,797 --> 00:11:31,638
把frame rate壓下來的一個函數

205
00:11:31,638 --> 00:11:35,501
然後裡面就是自己寫

206
00:11:35,501 --> 00:11:38,964
就是蠻hacking的方式去寫說

207
00:11:38,964 --> 00:11:41,506
它怎麼樣去壓那個frame rate

208
00:11:41,506 --> 00:11:42,426
但總之就是靠你

209
00:11:44,658 --> 00:11:48,721
一個frame是16點多秒的概念去做控制

210
00:11:48,721 --> 00:11:53,345
那如果今天我說說搞不好我的電腦突然間卡頓

211
00:11:53,345 --> 00:11:55,647
或者是突然間效能變差

212
00:11:55,647 --> 00:11:57,989
然後只剩下15fps

213
00:11:57,989 --> 00:12:01,592
我們就改成66好了

214
00:12:01,592 --> 00:12:03,993
那你就會發現

215
00:12:03,993 --> 00:12:07,296
這就變成是一般人現在在玩遊戲應該是不能接受的狀態

216
00:12:07,296 --> 00:12:11,099
就算我的畫格率變低了

217
00:12:11,702 --> 00:12:16,206
你應該不能接受說我的遊戲整個就變慢四倍

218
00:12:16,206 --> 00:12:18,088
它的邏輯基本上是對的沒有錯

219
00:12:18,088 --> 00:12:22,732
就是子彈的密度跟發射的方式都是對的

220
00:12:22,732 --> 00:12:26,916
但是它的速度就是慢了四倍

221
00:12:26,916 --> 00:12:31,201
那假設你今天剛好跑到一個可能沒有V-Sync的

222
00:12:32,926 --> 00:12:37,868
電腦然後你跑到就是60fps的4倍速度

223
00:12:37,868 --> 00:12:40,629
這240fps

224
00:12:40,629 --> 00:12:46,012
那我先把那個VC關掉

225
00:12:46,012 --> 00:12:51,674
他就用標的

226
00:12:51,674 --> 00:12:55,776
好那所以我們現在要把delta time加進來

227
00:12:55,776 --> 00:12:59,118
那delta time加進來我這邊做法就是跟剛shuttlecode

228
00:12:59,118 --> 00:13:00,078
就是那個虛擬碼寫的

229
00:13:02,157 --> 00:13:04,598
方式就還算蠻類似的,就是這邊有old time

230
00:13:04,598 --> 00:13:07,520
然後每一次

231
00:13:07,520 --> 00:13:09,841
就是每跑一個frame我都把新時間指定給舊時間

232
00:13:09,841 --> 00:13:12,602
然後新時間去抓一個

233
00:13:12,602 --> 00:13:14,043
這個STL提供的系統時間

234
00:13:14,043 --> 00:13:16,304
然後把delta time算出來

235
00:13:16,304 --> 00:13:19,545
然後這個logic就是update的部分

236
00:13:19,545 --> 00:13:21,326
那我就

237
00:13:21,326 --> 00:13:23,347
把delta time傳進去

238
00:13:23,347 --> 00:13:25,288
然後

239
00:13:25,288 --> 00:13:27,469
實際上在跑執行的時候

240
00:13:27,469 --> 00:13:29,630
譬如說我要看

241
00:13:29,630 --> 00:13:29,790
呃我的

242
00:13:31,998 --> 00:13:39,320
遊戲邏輯就是Logic的部分

243
00:13:39,320 --> 00:13:41,281
這個版本是沒有Delta Time, 上面這個版本是有

244
00:13:41,281 --> 00:13:47,342
有Delta Time的情況下, 我就把DT傳給玩家跟子彈

245
00:13:47,342 --> 00:13:50,043
然後一樣一路往裡面傳

246
00:13:50,043 --> 00:13:53,243
那我的計算方式

247
00:13:53,243 --> 00:13:58,264
本來移動是很單純的直接

248
00:13:58,264 --> 00:14:00,965
Player 的 X 值會加上

249
00:14:02,185 --> 00:14:05,267
dx就等於是x軸向速度的意思

250
00:14:05,267 --> 00:14:06,168
那原本只是這樣算

251
00:14:06,168 --> 00:14:07,029
那我就改成上面這樣子

252
00:14:07,029 --> 00:14:08,690
using delta time之後

253
00:14:08,690 --> 00:14:11,332
我就改成上面這個樣子

254
00:14:11,332 --> 00:14:12,253
那因為我原本的那個參數

255
00:14:12,253 --> 00:14:15,876
這邊寫player speed是4

256
00:14:15,876 --> 00:14:18,518
那這個東西是直接用60fps的狀況

257
00:14:18,518 --> 00:14:19,379
狀況下去推估的

258
00:14:19,379 --> 00:14:21,060
所以我這邊的計算

259
00:14:21,060 --> 00:14:22,901
很簡單就只是把它呃

260
00:14:22,901 --> 00:14:22,941
應該就是說

261
00:14:27,582 --> 00:14:33,946
我已經知道我的DX跟DY是在60fps的條件下去設置的遊戲參數

262
00:14:33,946 --> 00:14:36,629
那我就假裝我現在還是60fps

263
00:14:36,629 --> 00:14:38,050
然後去反推這個數字

264
00:14:38,050 --> 00:14:45,255
所以後面這個場數就是用1000ms去除以60

265
00:14:45,255 --> 00:14:48,398
那這樣子執行之後

266
00:14:56,300 --> 00:15:02,221
就開始會看到有些比較奇怪的地方會出現

267
00:15:02,221 --> 00:15:04,802
第一個是

268
00:15:04,802 --> 00:15:07,682
因為我現在開始有做浮點數運算

269
00:15:07,682 --> 00:15:15,204
那 SDL 這邊沒有幫我做任何 Subpixel 位移的計算

270
00:15:15,204 --> 00:15:18,205
然後我所有的移動都必須要是整數

271
00:15:18,205 --> 00:15:19,925
所以你就可以看到這邊開始出現句詞

272
00:15:20,957 --> 00:15:27,159
因為我現在實際上算出來的 dx 跟 dy 它已經不是加 1 加 2 加 3 加 4 的整數了

273
00:15:27,159 --> 00:15:29,560
所以它就會有點歪歪的

274
00:15:29,560 --> 00:15:36,982
可是這個理論上在你的遊戲引擎或是 API 如果它有處理反句詞

275
00:15:36,982 --> 00:15:40,303
然後它有辦法去做 subpixel 的位移計算

276
00:15:40,303 --> 00:15:43,384
或者是說我們一般在做任何 3D 引擎裡面它應該都已經是

277
00:15:48,803 --> 00:15:52,724
3D型的概念應該都已經包含了所有的位移座標都是浮點數

278
00:15:52,724 --> 00:15:56,565
然後它最後才統一投影到2D平面framebuffer上

279
00:15:56,565 --> 00:16:01,146
所以這個情況在你們現在常用的引擎裡面應該是看不到的

280
00:16:01,146 --> 00:16:08,708
但是用SDL這樣子最傳統的API介面就還是會看到這樣的現象

281
00:16:08,708 --> 00:16:11,709
不過這樣現象其實對我今天要講的東西應該不是壞事

282
00:16:11,709 --> 00:16:16,090
因為剛好這樣子可以讓我今天想要展示的一些瑕疵更清楚

283
00:16:20,532 --> 00:16:27,457
總之我們現在已經有最基本的遊戲邏輯有delta time考慮的情況了

284
00:16:27,457 --> 00:16:33,700
可是接下來的一個問題就是說

285
00:16:33,700 --> 00:16:39,444
譬如說我現在如果把frame rate改掉

286
00:16:39,444 --> 00:16:40,744
譬如說我把frame rate不要變

287
00:16:40,744 --> 00:16:44,427
等一下,V-sync給我開

288
00:16:46,646 --> 00:16:49,967
假設我現在的frame rate把它改成

289
00:16:49,967 --> 00:16:55,569
再改回45fps好了

290
00:16:55,569 --> 00:16:59,510
66毫秒才跑一輪

291
00:16:59,510 --> 00:17:01,531
移動這樣沒問題

292
00:17:01,531 --> 00:17:03,932
你會看到是正確的速度

293
00:17:03,932 --> 00:17:05,552
只是說它每一格都很開

294
00:17:05,552 --> 00:17:11,474
然後可能畫面看起來有點不太流暢

295
00:17:11,474 --> 00:17:13,195
但是有個問題是

296
00:17:13,195 --> 00:17:15,676
它子彈發射的頻率也下降了

297
00:17:17,090 --> 00:17:18,211
這就變成是邏輯上的問題

298
00:17:18,211 --> 00:17:23,215
就是我的子彈射出去之後移動的速度是對的

299
00:17:23,215 --> 00:17:28,519
我的主角移動的速度也是對的

300
00:17:28,519 --> 00:17:30,400
這個在你遊戲突然間掉格的時候

301
00:17:30,400 --> 00:17:33,883
你可能會希望至少這部分邏輯是對的沒有錯

302
00:17:33,883 --> 00:17:35,444
可是如果你遊戲一掉格

303
00:17:35,444 --> 00:17:38,347
你的子彈發射數量就變少

304
00:17:38,347 --> 00:17:41,349
這就變成是你的Framerate還是影響到你的Gameplay

305
00:17:49,540 --> 00:17:53,061
所以這個問題就變成你需要想辦法去解決

306
00:17:53,061 --> 00:17:56,642
那

307
00:17:56,642 --> 00:17:57,382
所以

308
00:17:57,382 --> 00:17:59,043
下一個

309
00:17:59,043 --> 00:18:09,566
解決方案

310
00:18:09,566 --> 00:18:10,146
我這邊就是把

311
00:18:15,343 --> 00:18:20,226
子彈的Reload方式,原本子彈的Reload方式是像下面這一段

312
00:18:20,226 --> 00:18:26,250
就是這個Reload Time大於0的時候,每個Frame每跑一次就減1

313
00:18:26,250 --> 00:18:30,133
子彈發射完之後會把這個數值加1加回來

314
00:18:30,133 --> 00:18:31,574
那基本上就是

315
00:18:39,410 --> 00:18:41,912
照原本邏輯的話應該是我每一個frame

316
00:18:41,912 --> 00:18:44,314
我每跑一次update回圈

317
00:18:44,314 --> 00:18:47,597
我player都可以回到能發射子彈的狀態

318
00:18:47,597 --> 00:18:51,120
所以剛才會看到子彈連的這麼密

319
00:18:51,120 --> 00:18:54,243
好那我現在其實希望用正常的時間區間

320
00:18:54,243 --> 00:18:57,766
來控制我的子彈發射的頻率

321
00:18:57,766 --> 00:18:59,867
就譬如說我想要控制

322
00:18:59,867 --> 00:19:00,988
我現在改成這個

323
00:19:00,988 --> 00:19:03,010
就是frame rate fix這個模式

324
00:19:03,825 --> 00:19:07,667
那我就希望我的子彈可能是每40毫秒才會射一發

325
00:19:07,667 --> 00:19:09,367
而不是每個friend射一發

326
00:19:09,367 --> 00:19:11,348
是每40毫秒射一發

327
00:19:11,348 --> 00:19:13,268
那我上面這邊算法也就改了

328
00:19:13,268 --> 00:19:15,849
就改成說這reload time

329
00:19:15,849 --> 00:19:17,550
這單位就已經不是friend

330
00:19:17,550 --> 00:19:19,391
這reload time的單位變成是毫秒

331
00:19:19,391 --> 00:19:22,912
然後在reload time還大於0的情況

332
00:19:22,912 --> 00:19:25,413
我就減一次delta time

333
00:19:25,413 --> 00:19:27,953
因為我delta time進來可能是16毫秒

334
00:19:27,953 --> 00:19:28,233
16毫秒然後就減16減16

335
00:19:28,233 --> 00:19:30,174
或是有時候是17減16減17這樣

336
00:19:30,174 --> 00:19:33,275
然後把它減到等於0或小於0

337
00:19:33,275 --> 00:19:33,535
那就是

338
00:19:34,035 --> 00:19:35,276
它又回到可以發射的狀態

339
00:19:35,276 --> 00:19:43,583
等一下

340
00:19:43,583 --> 00:19:48,527
登登登

341
00:19:48,527 --> 00:19:51,450
應該把那個frame rate先調回來

342
00:19:51,450 --> 00:19:52,111
所以剛我用

343
00:19:54,963 --> 00:19:58,347
16毫秒每frame的速度在跑的時候其實等於是60fps

344
00:19:58,347 --> 00:20:00,870
然後它每一秒跑60張

345
00:20:00,870 --> 00:20:03,273
然後每一張都會射一顆子彈

346
00:20:03,273 --> 00:20:04,935
那現在可能變成是

347
00:20:04,935 --> 00:20:08,419
它會比較接近每一秒會射25顆子彈左右

348
00:20:16,741 --> 00:20:20,782
可是到這個情況還是會發現一些蠻奇怪的狀況

349
00:20:20,782 --> 00:20:26,024
就是它的子彈間距其實並不均等

350
00:20:26,024 --> 00:20:31,205
那這有一小部分當然也是因為我的子彈現在所有的位移它都必須要是整數

351
00:20:31,205 --> 00:20:34,946
所以它本來就會有一些抖動或是不均勻的情況

352
00:20:34,946 --> 00:20:39,907
可是你會看到它有好幾格明顯就比較大

353
00:20:39,907 --> 00:20:44,209
那我這邊可以把重力要素也加上去

354
00:20:44,209 --> 00:20:45,429
這樣可能會比較容易看

355
00:20:47,421 --> 00:20:59,538
就加一個假的重力,你就會發現很明顯在有重力影響的情況下

356
00:20:59,538 --> 00:21:03,123
你就知道它的直端好像就有曲線的感覺。

357
00:21:14,707 --> 00:21:19,448
那到這一步,接下來的問題就變成是

358
00:21:19,448 --> 00:21:25,110
我的子彈雖然是依照我Friend的DeltaTime

359
00:21:25,110 --> 00:21:26,651
去計算什麼時候可以發射

360
00:21:26,651 --> 00:21:30,332
那理論上應該會是在正確的時間發射出來

361
00:21:30,332 --> 00:21:36,814
但是呢,你的子彈發射的時候

362
00:21:36,814 --> 00:21:38,034
回到這個虛構code這邊

363
00:21:43,072 --> 00:21:48,736
你這個update在跑的時候

364
00:21:48,736 --> 00:21:50,798
譬如說

365
00:21:50,798 --> 00:21:51,919
怎麼舉例比較好

366
00:21:51,919 --> 00:21:53,781
譬如說我

367
00:21:53,781 --> 00:21:57,023
每跑一個frame第一個frame是

368
00:21:57,023 --> 00:21:59,906
0ms然後下一個frame是16ms

369
00:21:59,906 --> 00:22:02,128
然後再下一個frame可能是33ms

370
00:22:02,128 --> 00:22:04,190
然後

371
00:22:04,190 --> 00:22:04,590
一路往下這樣

372
00:22:06,713 --> 00:22:14,935
可是我沒有辦法保證這個DT執行的那一瞬間是剛好切在0.16.3350上面

373
00:22:14,935 --> 00:22:20,396
它實際上傳進去的DT可能會造成我第四個frame

374
00:22:20,396 --> 00:22:25,357
可能是第53ms才跑到update裡面

375
00:22:25,357 --> 00:22:31,058
中間其實有3ms被吃掉

376
00:22:31,058 --> 00:22:32,699
所以這個FIX2主要是在修這邊的問題

377
00:22:42,626 --> 00:22:45,148
所以FIX 2這邊就多了一個考量

378
00:22:45,148 --> 00:22:48,292
就是我在發射子彈的同時

379
00:22:48,292 --> 00:22:50,855
就我不只是reload time小於0的時候可以發射子彈

380
00:22:50,855 --> 00:22:56,542
而是我發射子彈的時候我還要考慮

381
00:22:56,542 --> 00:23:02,248
實際上我的時間從上一個frame過來的時候被吃了多少

382
00:23:02,248 --> 00:23:03,169
就是上一個frame

383
00:23:04,097 --> 00:23:06,517
給我的delta time 它吃到我這個frame應該是

384
00:23:06,517 --> 00:23:07,857
就多吃了幾毫秒的時間

385
00:23:07,857 --> 00:23:10,378
那因為我的real time是用減的嘛

386
00:23:10,378 --> 00:23:12,098
就譬如說我是從

387
00:23:12,098 --> 00:23:13,859
本來是40毫秒要發射一次

388
00:23:13,859 --> 00:23:15,119
然後可能40減16變成24

389
00:23:15,119 --> 00:23:18,240
然後再減16變成8

390
00:23:18,240 --> 00:23:18,980
那8再減16就會變成-8

391
00:23:18,980 --> 00:23:21,761
那這-8ms我必須要把它補回來

392
00:23:21,761 --> 00:23:22,921
所以我在發射子彈的時候

393
00:23:22,921 --> 00:23:23,041
就會變成

394
00:23:35,020 --> 00:23:37,842
我會另外做一個

395
00:23:37,842 --> 00:23:38,643
這邊是我

396
00:23:38,643 --> 00:23:39,784
子彈創建的過程

397
00:23:39,784 --> 00:23:41,145
那這可能是最傳統的C的

398
00:23:41,145 --> 00:23:42,806
MAYLOCK這個

399
00:23:42,806 --> 00:23:43,787
大家看不懂沒關係

400
00:23:43,787 --> 00:23:44,507
這就是NEW而已

401
00:23:44,507 --> 00:23:46,509
就是把它當NEW就好

402
00:23:46,509 --> 00:23:49,471
那總之我NEW了一個BULLET出來之後

403
00:23:49,471 --> 00:23:50,591
我在

404
00:23:50,591 --> 00:23:54,474
NEW的那一瞬間我就必須要

405
00:23:54,474 --> 00:23:56,035
讓他跑一次

406
00:23:56,035 --> 00:23:57,456
子彈的移動

407
00:23:57,456 --> 00:23:59,178
然後譬如說我剛剛有

408
00:23:59,178 --> 00:24:01,019
8ms被偷了

409
00:24:01,019 --> 00:24:02,860
所以我這8ms必須要

410
00:24:02,860 --> 00:24:04,661
加到他已經移動的距離裡面

411
00:24:11,587 --> 00:24:17,555
那你看這樣子基本上它就沒有剛剛那個一段一段的問題

412
00:24:17,555 --> 00:24:20,098
但其實我這邊程式還是有

413
00:24:20,098 --> 00:24:21,419
應該是有什麼地方還是寫錯了

414
00:24:21,419 --> 00:24:27,386
因為我主角在動的時候子彈就變得反而變醜了

415
00:24:27,386 --> 00:24:28,087
就有這種奇怪的情況

416
00:24:29,425 --> 00:24:32,567
就我現在的主角機移動速度是4

417
00:24:32,567 --> 00:24:35,788
然後我的子彈的移動速度也是4

418
00:24:35,788 --> 00:24:36,769
不考慮重力的話

419
00:24:36,769 --> 00:24:41,431
所以理論上我主角機跟子彈同時往前進的時候

420
00:24:41,431 --> 00:24:43,892
應該你會看到那個子彈會變成一直線才對

421
00:24:43,892 --> 00:24:47,394
但是其實它現在會這樣稍微劈劈剉劈劈剉

422
00:24:47,394 --> 00:24:50,215
那這個問題是就是我今天早上看

423
00:24:50,215 --> 00:24:51,896
你早上也還是看不出來是哪邊的問題

424
00:24:51,896 --> 00:24:53,477
對 所以就先這樣

425
00:24:58,494 --> 00:25:02,798
但是這個問題等一下有另外一個方法可以去減輕

426
00:25:02,798 --> 00:25:04,480
那總之我這邊算法就是一樣嘛

427
00:25:04,480 --> 00:25:09,525
就是我這個 function

428
00:25:09,525 --> 00:25:12,488
PlayerBallerMovement基本上它就已經是考慮dt的情況

429
00:25:12,488 --> 00:25:15,291
那同時這個dt也可以考慮到像剛剛那樣子

430
00:25:15,291 --> 00:25:19,276
它有那個時間從上一個上一個回合

431
00:25:21,060 --> 00:25:23,641
溢出來到這個frame的時間

432
00:25:23,641 --> 00:25:25,642
那它一樣可以用這個公式去計算

433
00:25:25,642 --> 00:25:27,263
理論上這樣計算應該是對的

434
00:25:27,263 --> 00:25:30,044
但是剛就有那個奇怪抖抖的情況

435
00:25:30,044 --> 00:25:32,906
好總之這樣看起來好像已經沒問題了

436
00:25:32,906 --> 00:25:35,988
可是呢假設你現在說

437
00:25:35,988 --> 00:25:37,348
我的遊戲現在好像還蠻順的

438
00:25:37,348 --> 00:25:39,770
可是我不小心又掉到12fps

439
00:25:39,770 --> 00:25:42,291
又掉到15fps怎麼辦

440
00:25:42,291 --> 00:25:43,491
好那這邊就會出現問題了

441
00:25:43,491 --> 00:25:43,772
好譬如說

442
00:25:48,657 --> 00:25:55,506
我再把它調回只有15fps的情況

443
00:25:55,506 --> 00:26:01,173
它又斷掉了

444
00:26:01,173 --> 00:26:02,034
對那為什麼它又斷掉呢

445
00:26:03,183 --> 00:26:08,384
因為我們剛設定子彈發射的頻率是

446
00:26:08,384 --> 00:26:10,025
就像他是機關槍好了

447
00:26:10,025 --> 00:26:13,986
他發射的頻率是40ms一發

448
00:26:13,986 --> 00:26:17,827
可是我剛剛的frame是66ms跑一frame

449
00:26:17,827 --> 00:26:21,327
所以其實我有可能一個frame裡面要發兩發子彈

450
00:26:21,327 --> 00:26:23,368
那這個情況下變成是

451
00:26:23,368 --> 00:26:25,168
我這個就是我還要這個也要另外考慮

452
00:26:25,168 --> 00:26:25,208
所以

453
00:26:32,902 --> 00:26:38,284
這時候我就把FIX3開起來

454
00:26:51,259 --> 00:26:53,580
剛剛我在判定我什麼時候可以發射子彈的時候

455
00:26:53,580 --> 00:26:55,441
我是用if去判定的

456
00:26:55,441 --> 00:26:58,222
所以我if player的reload time小於等於0

457
00:26:58,222 --> 00:26:59,842
我就可以發射子彈

458
00:26:59,842 --> 00:27:04,464
可是因為我現在知道我一個frame可能不只發射一發子彈

459
00:27:04,464 --> 00:27:05,744
所以我就把if改成y哦

460
00:27:05,744 --> 00:27:13,527
它變成一個迴圈

461
00:27:13,527 --> 00:27:16,248
基本上還是算就是比剛剛順一些這樣

462
00:27:16,248 --> 00:27:18,188
雖然你看得到這個是15fps的畫面

463
00:27:23,135 --> 00:27:27,418
像這些細節就是以前我自己在寫程式的時候都沒有注意過

464
00:27:27,418 --> 00:27:30,140
以前也會覺得說為什麼有些時候

465
00:27:30,140 --> 00:27:34,683
可能我的角色發射的子彈就有些不規則

466
00:27:34,683 --> 00:27:40,987
或者是有時候很多子彈會重疊在一起一次出現

467
00:27:40,987 --> 00:27:45,550
像這些細節其實我覺得在真正玩那種動作性比較高

468
00:27:45,550 --> 00:27:48,032
或者是說像彈幕遊戲、節奏遊戲之類的

469
00:27:48,032 --> 00:27:50,354
其實這些東西都還滿重要需要考慮的

470
00:27:52,924 --> 00:27:55,645
就是看到John Bro的演講之後

471
00:27:55,645 --> 00:27:57,006
我就把這東西整理一下這樣

472
00:27:57,006 --> 00:27:59,568
那John Bro他後面還有提到說

473
00:27:59,568 --> 00:28:03,189
另外一個改善的方式是

474
00:28:03,189 --> 00:28:06,031
就是因為我們現在螢幕大部分

475
00:28:06,031 --> 00:28:08,092
是鎖定在60fps嘛

476
00:28:08,092 --> 00:28:10,513
可是實際上我可以讓我的遊戲回圈

477
00:28:10,513 --> 00:28:12,774
不是用60fps在跑

478
00:28:12,774 --> 00:28:16,596
譬如說我的遊戲update可能是240fps

479
00:28:16,596 --> 00:28:20,458
但是我可能模擬了三次或四次之後

480
00:28:20,458 --> 00:28:21,739
我才畫一次到畫面上

481
00:28:23,096 --> 00:28:27,060
這樣的話理論上會讓誤差變小,或是讓畫面變得更順一點。

482
00:28:27,060 --> 00:28:32,965
我本來畫面可能會在 frame 沒有切齊的時候跳一下,

483
00:28:32,965 --> 00:28:37,249
但是如果我的遊戲更新、邏輯更新間隔更密的話,

484
00:28:37,249 --> 00:28:39,311
那種跳一下的情況相對會比較不明顯。

485
00:28:46,938 --> 00:28:57,021
可以看一下像我剛剛講的,我在移動的時候會有這個可能我剛剛沒有修好的問題,移動的時候它子彈就很明顯不一致。

486
00:28:57,021 --> 00:29:13,807
但是如果我現在考慮回到60fps的狀態,然後我想辦法用240fps的頻率去跑遊戲更新的話,剛剛那個抖動的情況就會減緩蠻多的。

487
00:29:13,807 --> 00:29:16,128
我做這個方式也是有點駭客。

488
00:29:17,434 --> 00:29:18,615
科學根據

489
00:29:18,615 --> 00:29:20,497
就是我先把它改成

490
00:29:20,497 --> 00:29:24,241
這邊是改成4點多秒

491
00:29:24,241 --> 00:29:27,124
就是大概240fps的方式

492
00:29:27,124 --> 00:29:28,746
去控制frame rate

493
00:29:28,746 --> 00:29:33,411
可是我frame rate

494
00:29:33,411 --> 00:29:34,532
我不要每一次都畫

495
00:29:37,535 --> 00:29:46,978
所以我這邊有一個很簡單的計數器,就是0,1,2,3,4,5,6,GX往上加,然後它可以被3整除的時候我才會跑一次畫畫面這樣。

496
00:29:46,978 --> 00:30:01,602
那之前我是每一個frame都畫,那現在我用調成240fps,我每個frame都畫也沒有意義,因為我會被Vsync擋住,那所以我是用這個方式去繞過Vsync這樣。

497
00:30:07,520 --> 00:30:10,621
基本上這樣就回到比較順暢的狀態

498
00:30:10,621 --> 00:30:16,542
然後移動的時候它抖動就算好很多

499
00:30:16,542 --> 00:30:18,143
但是還是蠻明顯的

500
00:30:18,143 --> 00:30:19,663
因為我現在是把

501
00:30:19,663 --> 00:30:21,083
其實另外一個很明顯的原因是

502
00:30:21,083 --> 00:30:27,865
因為我把640x360的畫面直接投到全螢幕上來

503
00:30:27,865 --> 00:30:30,945
所以你會覺得任何誤差都很大

504
00:30:30,945 --> 00:30:32,646
但是這樣也是比較方便讓大家看

505
00:30:32,646 --> 00:30:34,766
就是這邊其實都會造成誤差

506
00:30:44,087 --> 00:30:50,949
這邊還只是基本上遊戲邏輯要做各種調適的部分而已

507
00:30:50,949 --> 00:30:54,670
就是你要想辦法讓你的子彈移動、角色移動

508
00:30:54,670 --> 00:30:57,251
還有你的物理模擬

509
00:30:57,251 --> 00:31:01,312
然後很多遊戲規則判定

510
00:31:01,312 --> 00:31:02,733
你可能都需要做這些考量

511
00:31:02,733 --> 00:31:03,753
因為譬如說你遊戲比較複雜一點

512
00:31:03,753 --> 00:31:04,013
譬如說是

513
00:31:10,260 --> 00:31:14,343
很多隻敵人或是說有一些機關

514
00:31:14,343 --> 00:31:18,505
會同時在很接近的Frame裡觸發的時候

515
00:31:18,505 --> 00:31:23,228
譬如說我有可能60fps的情況下

516
00:31:23,228 --> 00:31:27,070
我的陷阱或是說某一個會攻擊你的敵人

517
00:31:27,070 --> 00:31:27,690
他會發射砲彈

518
00:31:27,690 --> 00:31:30,011
然後你也會發射砲彈去打他

519
00:31:30,011 --> 00:31:35,615
那有可能在這60fps同一個Update Frame裡面

520
00:31:35,615 --> 00:31:37,876
你攻擊他的事件跟他射擊你的事件

521
00:31:37,876 --> 00:31:38,376
可能會同時發生

522
00:31:40,244 --> 00:31:45,005
那這個時候就完全看你的程式架構當初是怎麼寫的

523
00:31:45,005 --> 00:31:47,506
或甚至是你根本就沒有特別寫這個判定

524
00:31:47,506 --> 00:31:52,427
你可能是全部都丟到譬如說Unity引擎的Event事件裡面

525
00:31:52,427 --> 00:31:54,008
讓他自己去幫你管理

526
00:31:54,008 --> 00:31:58,589
那到底是先註冊事件的會先觸發

527
00:31:58,589 --> 00:32:01,730
還是後註冊事件的會先觸發

528
00:32:01,730 --> 00:32:03,971
就其實大家就要猜

529
00:32:03,971 --> 00:32:06,811
好那所以理論上你如果把

530
00:32:08,283 --> 00:32:12,386
邏輯模擬的部分提高到譬如說240fps之類的話

531
00:32:12,386 --> 00:32:17,329
像那樣子邏輯衝突的情況就會降更低

532
00:32:17,329 --> 00:32:22,273
那這些邏輯衝突可能會造成一些很難測得出來

533
00:32:22,273 --> 00:32:26,276
但是萬一被玩家遇到的時候又會很不爽的情況

534
00:32:26,276 --> 00:32:29,519
譬如說玩家會覺得明明是我先射他的

535
00:32:29,519 --> 00:32:30,940
那為什麼我死了

536
00:32:30,940 --> 00:32:33,222
或是明明這個平台我應該跳得上去

537
00:32:33,222 --> 00:32:35,003
為什麼我跳不上去之類的

538
00:32:37,118 --> 00:32:42,121
這些事件其實我想應該多少都會有人

539
00:32:42,121 --> 00:32:43,822
不管是你開發自己遊戲

540
00:32:43,822 --> 00:32:44,742
還是你在玩別人遊戲的時候

541
00:32:44,742 --> 00:32:45,683
你可能多少都有遇過

542
00:32:45,683 --> 00:32:46,864
只是你也很難重現

543
00:32:46,864 --> 00:32:48,585
然後你也不知道為什麼會發生

544
00:32:48,585 --> 00:32:51,006
或是有時候覺得你手感就怪怪的

545
00:32:51,006 --> 00:32:54,689
那像這些東西其實你都需要這些額外的調整

546
00:32:54,689 --> 00:32:57,430
那剛剛講到這邊都還只是遊戲邏輯的部分

547
00:32:57,430 --> 00:33:03,594
接下來另外一個部分更難解的地方是

548
00:33:03,594 --> 00:33:05,255
我們回到最基本的Shuttlecode

549
00:33:06,768 --> 00:33:09,529
其實剛剛都在講update這一塊而已

550
00:33:09,529 --> 00:33:10,630
那render反正就render嘛

551
00:33:10,630 --> 00:33:13,270
你也沒辦法控制 先不管它

552
00:33:13,270 --> 00:33:15,551
可是這個shuttle core裡面

553
00:33:15,551 --> 00:33:19,272
最大的隱形敵人其實是input

554
00:33:19,272 --> 00:33:23,293
input是一個很微妙的狀態

555
00:33:23,293 --> 00:33:30,575
就是你並不知道你到底在什麼時間點

556
00:33:30,575 --> 00:33:34,036
讀到了玩家按下某一個按鍵的這個事情

557
00:33:36,273 --> 00:33:40,636
因為...呃...

558
00:33:40,636 --> 00:33:44,158
就是有...就是像剛剛我下面這個舉例一樣的情況

559
00:33:44,158 --> 00:33:47,701
就玩家可能在第52ms的時候按下按鍵

560
00:33:47,701 --> 00:33:51,823
玩家可能在第7ms的時候按下按鍵

561
00:33:51,823 --> 00:33:55,686
但是你沒有辦法在這個區間裡面去反應出來玩家到底在什麼地方按下

562
00:33:57,285 --> 00:34:02,027
一般的做法都會直接把輸入推遲到下一個Frame

563
00:34:02,027 --> 00:34:03,567
譬如說7ms玩一下按一下按鍵

564
00:34:03,567 --> 00:34:05,688
它就是在第16ms才會反應

565
00:34:05,688 --> 00:34:10,930
然後它會當成第16ms這個Frame的輸入

566
00:34:10,930 --> 00:34:13,190
然後在這一段去跑模擬

567
00:34:13,190 --> 00:34:15,351
就是它會跑16到33的模擬

568
00:34:15,351 --> 00:34:17,892
但是它16到33ms這段的模擬是用

569
00:34:19,868 --> 00:34:22,829
你在第 7ms 的時候輸入的資料

570
00:34:22,829 --> 00:34:26,009
所以當你遊戲 frame 數

571
00:34:26,009 --> 00:34:27,290
你的 FPS 數下降

572
00:34:27,290 --> 00:34:29,210
譬如說你不小心掉到 30fps

573
00:34:29,210 --> 00:34:30,370
或是 20fps 的時候

574
00:34:30,370 --> 00:34:33,351
突然間手把操作就很頓

575
00:34:33,351 --> 00:34:36,252
因為你實際上按下按鍵之後

576
00:34:36,252 --> 00:34:39,192
可能過了 10ms 20ms

577
00:34:39,192 --> 00:34:41,953
才反映到遊戲邏輯中

578
00:34:41,953 --> 00:34:45,034
那可能畫到畫面上又更久

579
00:34:45,034 --> 00:34:45,854
所以這種情況會變得很難解

580
00:34:47,877 --> 00:34:54,021
那有一種做法是你可能要另外跑一個input的執行序

581
00:34:54,021 --> 00:35:00,685
就是input要跟遊戲邏輯還有遊戲繪圖完全分開

582
00:35:00,685 --> 00:35:04,948
但是執行序這件事情本身就很難同步嘛

583
00:35:04,948 --> 00:35:08,129
你也不知道a執行序先執行還是b執行序先執行

584
00:35:08,129 --> 00:35:11,471
那這個都會有很微妙的情況發生

585
00:35:11,471 --> 00:35:14,453
那另外一個做法就是你讓你的input

586
00:35:14,453 --> 00:35:14,834
因為剛剛我們已經試過用240

587
00:35:17,375 --> 00:35:22,057
FPS的方式在做邏輯更新了

588
00:35:22,057 --> 00:35:24,038
那另外一個做法就是說

589
00:35:24,038 --> 00:35:27,660
你可以把你的input放到邏輯更新裡面

590
00:35:27,660 --> 00:35:31,422
所以我的手把的操作變成是

591
00:35:31,422 --> 00:35:38,026
我也是用240fps的頻率在去讀說

592
00:35:38,026 --> 00:35:40,027
我到底鍵盤或是我的滑鼠或是我的搖桿

593
00:35:40,027 --> 00:35:42,528
有沒有按鍵被按下去

594
00:35:42,528 --> 00:35:42,809
那在

595
00:35:43,929 --> 00:35:46,851
非常講求操作精確度的遊戲裡面

596
00:35:46,851 --> 00:35:48,172
譬如說格鬥遊戲

597
00:35:48,172 --> 00:35:51,114
像格鬥遊戲很多操作可能都是

598
00:35:51,114 --> 00:35:53,676
一幅兩幅之內要做出來的操作

599
00:35:53,676 --> 00:35:59,000
或者是那種很吃精確判斷的

600
00:35:59,000 --> 00:36:01,622
彈幕遊戲、節奏遊戲之類的

601
00:36:01,622 --> 00:36:04,745
這些地方可能都會

602
00:36:04,745 --> 00:36:08,968
被所謂的 input delay 會影響到

603
00:36:08,968 --> 00:36:10,549
那之前我

604
00:36:11,670 --> 00:36:14,051
剛看完 John Brode 的影片的時候我提出來

605
00:36:14,051 --> 00:36:15,952
然後也是有些朋友講說

606
00:36:15,952 --> 00:36:18,732
其實在 Unity 裡面要做到這件事

607
00:36:18,732 --> 00:36:19,813
其實好像不太容易

608
00:36:19,813 --> 00:36:24,534
因為 Unity 裡面的 input 是跟 update 綁定的

609
00:36:24,534 --> 00:36:26,795
所以你是畫 30fps

610
00:36:26,795 --> 00:36:28,875
你的 input 就是讀 30fps

611
00:36:28,875 --> 00:36:30,135
你是畫 60fps

612
00:36:30,135 --> 00:36:32,656
你的 input 就是讀 60fps

613
00:36:32,656 --> 00:36:34,116
那理論上

614
00:36:35,090 --> 00:36:38,873
在那樣情況下你要做到更高精度的操作輸入

615
00:36:38,873 --> 00:36:39,614
還有邏輯判斷

616
00:36:39,614 --> 00:36:43,737
你可能就會需要讓你的Rendering直接也拉到120

617
00:36:43,737 --> 00:36:49,021
你才有辦法做更精確的操作

618
00:36:49,021 --> 00:36:53,504
對那就是只是把這些事情提出來跟大家分享一下

619
00:36:53,504 --> 00:36:54,845
對因為我自己也是很久沒寫程式了

620
00:36:54,845 --> 00:36:59,949
然後就早上寫程式也是寫到卡卡的

621
00:36:59,949 --> 00:37:02,571
好那等一下如果

622
00:37:03,423 --> 00:37:07,826
有相關的 譬如說有做過高速動作遊戲

623
00:37:07,826 --> 00:37:11,508
節奏遊戲 還是其他類型彈幕遊戲的朋友

624
00:37:11,508 --> 00:37:17,451
就是歡迎 就是盡量多多指教

625
00:37:17,451 --> 00:37:22,293
因為其實我自己沒有寫過這些遊戲

626
00:37:22,293 --> 00:37:25,335
那大概我今天其實要

627
00:37:25,335 --> 00:37:29,697
就是程式要分享的部分大概就只有這些

628
00:37:29,697 --> 00:37:31,478
那如果有人想要看 code 的話也可以

629
00:37:32,679 --> 00:37:34,671
反正就是等一下自由時間再到前面來看

